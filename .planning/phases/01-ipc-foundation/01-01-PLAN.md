---
phase: 01-ipc-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - python/crystalmath/server/__init__.py
  - python/crystalmath/server/handlers.py
  - pyproject.toml
autonomous: true

must_haves:
  truths:
    - "Python server listens on Unix domain socket"
    - "Server responds to JSON-RPC 2.0 requests"
    - "system.ping returns pong with timestamp"
    - "Server handles Content-Length framing correctly"
  artifacts:
    - path: "python/crystalmath/server/__init__.py"
      provides: "JsonRpcServer class with serve_forever()"
      min_lines: 80
    - path: "python/crystalmath/server/handlers.py"
      provides: "Handler registry with system.ping"
      exports: ["handle_system_ping", "HANDLER_REGISTRY"]
  key_links:
    - from: "python/crystalmath/server/__init__.py"
      to: "python/crystalmath/api.py"
      via: "CrystalController.dispatch()"
      pattern: "controller\\.dispatch"
---

<objective>
Create the Python JSON-RPC server that listens on a Unix domain socket and handles requests.

Purpose: This is the Python-side of the IPC boundary that replaces PyO3 embedded Python. The server uses asyncio for non-blocking I/O and delegates to the existing CrystalController.dispatch() method.

Output: A standalone server module that can be started via CLI and responds to JSON-RPC 2.0 requests.
</objective>

<execution_context>
@/Users/briansquires/.claude/get-shit-done/workflows/execute-plan.md
@/Users/briansquires/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/01-ipc-foundation/01-RESEARCH.md
@python/crystalmath/api.py (lines 270-383 for dispatch() pattern)
@docs/architecture/adr-003-ipc-boundary-design.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create JSON-RPC server module</name>
  <files>
    python/crystalmath/server/__init__.py
    python/crystalmath/server/handlers.py
  </files>
  <action>
Create the server module structure:

1. Create `python/crystalmath/server/__init__.py` with:
   - `JsonRpcServer` class using `asyncio.start_unix_server()`
   - Content-Length framing for message reads/writes (same as LSP protocol)
   - Client connection handler that reads messages and calls dispatcher
   - Socket path resolution: `$XDG_RUNTIME_DIR/crystalmath.sock` or `/tmp/crystalmath-{uid}.sock`
   - Stale socket cleanup (unlink before bind if not in use)
   - Socket permissions (0o600) after creation

2. Create `python/crystalmath/server/handlers.py` with:
   - `HANDLER_REGISTRY` dict mapping method names to handlers
   - `handle_system_ping()` returning `{"pong": True, "timestamp": "ISO8601"}`
   - Handler signature: `async def handler(controller, params: dict) -> dict`

Key implementation details from RESEARCH.md:
- Use `asyncio.start_unix_server()` (stdlib, no external deps)
- Message framing: `Content-Length: {len}\r\n\r\n{json_body}`
- Read headers until empty line, then `reader.readexactly(content_length)`
- Call `controller.dispatch(request_json)` for requests (reuse existing dispatch)
- Cap message size at 100MB to prevent OOM
- Handle `asyncio.IncompleteReadError` for client disconnects

Reference the existing framing pattern in `src/lsp.rs` lines 263-352.
  </action>
  <verify>
```bash
# Server module imports without errors
cd /Users/briansquires/CRYSTAL23/crystalmath && uv run python -c "from crystalmath.server import JsonRpcServer; print('OK')"
```
  </verify>
  <done>
- JsonRpcServer class exists with `serve_forever()` method
- Content-Length framing implemented for read/write
- Socket path resolution works (XDG or /tmp fallback)
- system.ping handler registered
  </done>
</task>

<task type="auto">
  <name>Task 2: Add server CLI entry point</name>
  <files>
    python/crystalmath/server/__init__.py
    pyproject.toml
  </files>
  <action>
Add CLI entry point for starting the server:

1. In `python/crystalmath/server/__init__.py`, add:
   - `def main()` function that parses args and runs server
   - `--socket PATH` option to override socket path
   - `--foreground` flag (default) vs `--daemon` (future)
   - `--timeout SECONDS` for inactivity shutdown (default 300s, 0 to disable)
   - Signal handling: SIGTERM/SIGINT trigger graceful shutdown
   - Logging to stderr with timestamp prefix

2. In `pyproject.toml`, add entry point under `[project.scripts]`:
   ```toml
   crystalmath-server = "crystalmath.server:main"
   ```

3. Server startup sequence:
   - Check for stale socket (try connect, if refused, unlink)
   - Create CrystalController (reuse existing factory)
   - Start asyncio server
   - Log "Listening on {socket_path}"
   - Run until signal or inactivity timeout

Reference ADR-003 for lifecycle commands.
  </action>
  <verify>
```bash
# CLI entry point exists
cd /Users/briansquires/CRYSTAL23/crystalmath && uv run crystalmath-server --help

# Server starts and can be stopped with Ctrl+C (manual test)
# timeout 2 uv run crystalmath-server --foreground 2>&1 || true
```
  </verify>
  <done>
- `crystalmath-server` CLI command available via uv
- --socket, --foreground, --timeout options work
- Server logs startup message and can be stopped with SIGINT
- Stale socket detection works
  </done>
</task>

</tasks>

<verification>
```bash
cd /Users/briansquires/CRYSTAL23/crystalmath

# 1. Module imports cleanly
uv run python -c "from crystalmath.server import JsonRpcServer, main; print('Import OK')"

# 2. CLI entry point exists
uv run crystalmath-server --help | grep -q "socket" && echo "CLI OK"

# 3. Quick server test (start, check socket, stop)
timeout 3 bash -c '
  uv run crystalmath-server --socket /tmp/test-ipc.sock &
  SERVER_PID=$!
  sleep 1
  test -S /tmp/test-ipc.sock && echo "Socket created"
  kill $SERVER_PID 2>/dev/null
  wait
' || true
```
</verification>

<success_criteria>
- Python server module exists at `python/crystalmath/server/`
- `crystalmath-server` CLI command is registered and runnable
- Server creates Unix socket and listens for connections
- system.ping handler is registered and returns valid response
- Server handles graceful shutdown on SIGINT/SIGTERM
</success_criteria>

<output>
After completion, create `.planning/phases/01-ipc-foundation/01-01-SUMMARY.md`
</output>
