---
phase: 01-ipc-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/ipc.rs
  - src/ipc/client.rs
  - src/ipc/framing.rs
  - src/lib.rs
  - Cargo.toml
autonomous: true

must_haves:
  truths:
    - "Rust client connects to Unix domain socket"
    - "Client sends JSON-RPC 2.0 requests with Content-Length framing"
    - "Client receives and parses JSON-RPC 2.0 responses"
    - "30-second timeout on requests prevents hangs"
  artifacts:
    - path: "src/ipc.rs"
      provides: "IpcClient struct with connect() and call() methods"
      min_lines: 100
    - path: "src/ipc/framing.rs"
      provides: "Content-Length message framing codec"
      exports: ["read_message", "write_message"]
  key_links:
    - from: "src/ipc.rs"
      to: "src/bridge.rs"
      via: "Reuses JsonRpcRequest/JsonRpcResponse types"
      pattern: "use crate::bridge::\\{JsonRpcRequest"
---

<objective>
Create the Rust IPC client that connects to the Python server via Unix domain socket.

Purpose: This is the Rust-side of the IPC boundary. The client uses tokio for async I/O and reuses the existing JSON-RPC types from bridge.rs.

Output: An IpcClient struct that can connect, send requests, and receive responses with proper timeout handling.
</objective>

<execution_context>
@/Users/briansquires/.claude/get-shit-done/workflows/execute-plan.md
@/Users/briansquires/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/01-ipc-foundation/01-RESEARCH.md
@src/bridge.rs (lines 26-102 for JSON-RPC types)
@src/lsp.rs (lines 263-352 for Content-Length framing pattern)
@docs/architecture/adr-003-ipc-boundary-design.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IPC client module with framing</name>
  <files>
    src/ipc.rs
    src/ipc/client.rs
    src/ipc/framing.rs
    src/lib.rs
  </files>
  <action>
Create the IPC client module structure:

1. Create `src/ipc.rs` as module root:
   ```rust
   //! IPC client for communication with crystalmath-server.
   mod client;
   mod framing;

   pub use client::IpcClient;
   pub use framing::{read_message, write_message};
   ```

2. Create `src/ipc/framing.rs` with Content-Length codec:
   - `async fn read_message(reader: &mut BufReader<ReadHalf<UnixStream>>) -> Result<String>`
     - Read headers until empty line (handle both CRLF and LF)
     - Extract Content-Length (case-insensitive header parsing)
     - Cap at 100MB to prevent OOM
     - Use `read_exact()` for body
   - `async fn write_message(writer: &mut WriteHalf<UnixStream>, body: &str) -> Result<()>`
     - Format: `Content-Length: {len}\r\n\r\n{body}`
     - Flush after write

   Adapt from `src/lsp.rs` lines 263-352 (the pattern is identical).

3. Create `src/ipc/client.rs` with IpcClient:
   ```rust
   pub struct IpcClient {
       reader: BufReader<tokio::io::ReadHalf<UnixStream>>,
       writer: tokio::io::WriteHalf<UnixStream>,
       request_id: AtomicU64,
   }

   impl IpcClient {
       pub async fn connect(socket_path: &Path) -> Result<Self>;
       pub async fn call(&mut self, method: &str, params: Value) -> Result<Value>;
       fn next_id(&self) -> u64;
   }
   ```

4. In `src/lib.rs`, add:
   ```rust
   pub mod ipc;
   ```

Key implementation details from RESEARCH.md:
- Use `tokio::net::UnixStream` (already available via tokio `net` feature)
- Reuse `JsonRpcRequest` and `JsonRpcResponse` from `bridge.rs` (pub use them)
- `call()` builds request, serializes, sends, reads response, deserializes
- No new Cargo dependencies needed (tokio, serde_json already present)
  </action>
  <verify>
```bash
cd /Users/briansquires/CRYSTAL23/crystalmath

# Module compiles
cargo check 2>&1 | head -20

# Types are accessible
cargo build 2>&1 | grep -E "error|warning:" | head -10 || echo "Build OK"
```
  </verify>
  <done>
- IpcClient struct exists with connect() and call() methods
- Content-Length framing in separate framing module
- Module integrated into src/lib.rs
- No new Cargo dependencies added
  </done>
</task>

<task type="auto">
  <name>Task 2: Add timeout and error handling</name>
  <files>
    src/ipc/client.rs
    Cargo.toml
  </files>
  <action>
Add robust timeout and error handling to IpcClient:

1. In `src/ipc/client.rs`, enhance `call()` method:
   - Wrap send_receive in `tokio::time::timeout(Duration::from_secs(30), ...)`
   - On timeout: return descriptive error "Request timed out after 30s"
   - On connection error: return "Connection lost" with details
   - Parse JSON-RPC error responses and convert to anyhow::Error

2. Add `IpcError` enum for specific error cases:
   ```rust
   #[derive(Debug, thiserror::Error)]
   pub enum IpcError {
       #[error("Connection failed: {0}")]
       ConnectionFailed(#[from] std::io::Error),
       #[error("Request timed out after {0}s")]
       Timeout(u64),
       #[error("Protocol error: {0}")]
       Protocol(String),
       #[error("Server error {code}: {message}")]
       ServerError { code: i32, message: String },
   }
   ```

3. In `Cargo.toml`, verify thiserror is present (it should be, if not add it):
   ```toml
   thiserror = "1.0"
   ```

4. Add socket path resolution function:
   ```rust
   pub fn default_socket_path() -> PathBuf {
       if let Ok(runtime_dir) = std::env::var("XDG_RUNTIME_DIR") {
           PathBuf::from(runtime_dir).join("crystalmath.sock")
       } else {
           PathBuf::from(format!("/tmp/crystalmath-{}.sock", unsafe { libc::getuid() }))
       }
   }
   ```

5. Add reconnection helper (for TUI startup):
   ```rust
   pub async fn connect_with_retry(socket_path: &Path, max_attempts: u32) -> Result<Self> {
       for attempt in 1..=max_attempts {
           match Self::connect(socket_path).await {
               Ok(client) => return Ok(client),
               Err(e) if attempt < max_attempts => {
                   tokio::time::sleep(Duration::from_millis(100 * attempt as u64)).await;
               }
               Err(e) => return Err(e),
           }
       }
       unreachable!()
   }
   ```
  </action>
  <verify>
```bash
cd /Users/briansquires/CRYSTAL23/crystalmath

# Builds without errors
cargo build 2>&1 | grep -E "^error" || echo "No errors"

# Unit tests pass
cargo test ipc 2>&1 | tail -20
```
  </verify>
  <done>
- 30-second timeout on all requests
- IpcError enum with specific error types
- default_socket_path() resolves XDG or /tmp
- connect_with_retry() for robust startup
- thiserror dependency confirmed
  </done>
</task>

</tasks>

<verification>
```bash
cd /Users/briansquires/CRYSTAL23/crystalmath

# 1. Module compiles
cargo check

# 2. Build succeeds
cargo build

# 3. Run IPC module tests (if any)
cargo test ipc -- --nocapture 2>&1 | tail -30

# 4. Check IpcClient is public
cargo doc --no-deps 2>&1 | grep -i "ipc" || echo "Doc check passed"
```
</verification>

<success_criteria>
- Rust IPC client module exists at `src/ipc/`
- IpcClient::connect() and IpcClient::call() methods work
- Content-Length framing matches Python server's protocol
- 30-second timeout prevents hung requests
- Error types provide actionable messages
- No new external dependencies (uses existing tokio, serde_json)
</success_criteria>

<output>
After completion, create `.planning/phases/01-ipc-foundation/01-02-SUMMARY.md`
</output>
