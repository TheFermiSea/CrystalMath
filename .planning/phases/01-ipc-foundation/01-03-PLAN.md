---
phase: 01-ipc-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - src/ipc/client.rs
  - tests/ipc_integration.rs
autonomous: true

must_haves:
  truths:
    - "TUI auto-starts Python server if not running"
    - "system.ping roundtrip completes in < 10ms"
    - "Integration tests verify Rust-Python communication"
    - "Server process is spawned and managed correctly"
  artifacts:
    - path: "src/ipc/client.rs"
      provides: "ensure_server_running() function"
      contains: "Command::new"
    - path: "tests/ipc_integration.rs"
      provides: "Integration tests for IPC"
      min_lines: 50
  key_links:
    - from: "src/ipc/client.rs"
      to: "crystalmath-server"
      via: "Command::new spawns server process"
      pattern: "crystalmath-server"
---

<objective>
Add auto-start logic so the TUI spawns the Python server if not running, and create integration tests verifying the full IPC stack.

Purpose: Zero-config user experience - the TUI just works without manual server management. Integration tests verify the contract between Rust client and Python server.

Output: Working auto-start with integration tests that pass.
</objective>

<execution_context>
@/Users/briansquires/.claude/get-shit-done/workflows/execute-plan.md
@/Users/briansquires/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/01-ipc-foundation/01-RESEARCH.md
@.planning/phases/01-ipc-foundation/01-01-SUMMARY.md
@.planning/phases/01-ipc-foundation/01-02-SUMMARY.md
@docs/architecture/adr-003-ipc-boundary-design.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement auto-start logic</name>
  <files>
    src/ipc/client.rs
  </files>
  <action>
Add server auto-start capability to IpcClient:

1. Add `ensure_server_running()` function in `src/ipc/client.rs`:
   ```rust
   /// Ensures the crystalmath-server is running, starting it if necessary.
   ///
   /// Returns Ok(()) if server is running (or was started successfully).
   /// Returns Err if server could not be started within timeout.
   pub fn ensure_server_running(socket_path: &Path) -> Result<()> {
       // 1. Try connecting first (fast path - server already running)
       match std::os::unix::net::UnixStream::connect(socket_path) {
           Ok(_) => return Ok(()),
           Err(e) if e.kind() == std::io::ErrorKind::NotFound => {}
           Err(e) if e.kind() == std::io::ErrorKind::ConnectionRefused => {
               // Stale socket - server crashed, clean it up
               let _ = std::fs::remove_file(socket_path);
           }
           Err(e) => return Err(e.into()),
       }

       // 2. Server not running - spawn it
       tracing::info!("Starting crystalmath-server...");
       let _child = std::process::Command::new("crystalmath-server")
           .arg("--socket")
           .arg(socket_path)
           .stdout(std::process::Stdio::null())
           .stderr(std::process::Stdio::piped())
           .spawn()
           .context("Failed to start crystalmath-server")?;

       // 3. Wait for socket to appear (max 5 seconds)
       for _ in 0..50 {
           if socket_path.exists() {
               // Give server a moment to start accepting
               std::thread::sleep(Duration::from_millis(100));
               return Ok(());
           }
           std::thread::sleep(Duration::from_millis(100));
       }

       Err(anyhow!("Server failed to start within 5 seconds"))
   }
   ```

2. Add `connect_or_start()` convenience method:
   ```rust
   /// Connect to server, starting it if necessary.
   pub async fn connect_or_start(socket_path: &Path) -> Result<Self> {
       ensure_server_running(socket_path)?;
       Self::connect_with_retry(socket_path, 5).await
   }
   ```

3. Add server health check:
   ```rust
   /// Check if server is responsive via system.ping.
   pub async fn ping(&mut self) -> Result<Duration> {
       let start = std::time::Instant::now();
       let result = self.call("system.ping", serde_json::json!({})).await?;

       // Verify response structure
       if result.get("pong").and_then(|v| v.as_bool()) != Some(true) {
           return Err(anyhow!("Invalid ping response: {:?}", result));
       }

       Ok(start.elapsed())
   }
   ```

Key details from RESEARCH.md:
- Use blocking std::os::unix::net for initial connection check (faster than tokio)
- Spawn server as detached process (stdout null, stderr piped for debugging)
- Poll for socket existence, not immediate connect (server needs startup time)
- 5-second timeout matches ADR-003 specification
  </action>
  <verify>
```bash
cd /Users/briansquires/CRYSTAL23/crystalmath

# Code compiles
cargo check

# Ensure libc is available for getuid (or use alternative)
cargo build 2>&1 | grep -E "^error" || echo "Build OK"
```
  </verify>
  <done>
- ensure_server_running() spawns server if not running
- connect_or_start() combines auto-start with connection
- ping() method verifies server health
- Stale socket cleanup works
  </done>
</task>

<task type="auto">
  <name>Task 2: Create integration tests</name>
  <files>
    tests/ipc_integration.rs
  </files>
  <action>
Create integration tests that verify the full IPC stack:

1. Create `tests/ipc_integration.rs`:
   ```rust
   //! Integration tests for IPC client-server communication.
   //!
   //! These tests require the crystalmath Python package to be installed.
   //! Run with: cargo test --test ipc_integration

   use std::path::PathBuf;
   use std::time::Duration;
   use tokio::time::timeout;

   use crystalmath::ipc::{IpcClient, ensure_server_running, default_socket_path};

   /// Get a unique socket path for this test.
   fn test_socket_path() -> PathBuf {
       let pid = std::process::id();
       let timestamp = std::time::SystemTime::now()
           .duration_since(std::time::UNIX_EPOCH)
           .unwrap()
           .as_nanos();
       PathBuf::from(format!("/tmp/crystalmath-test-{}-{}.sock", pid, timestamp))
   }

   /// Clean up socket file after test.
   fn cleanup_socket(path: &PathBuf) {
       let _ = std::fs::remove_file(path);
   }

   #[tokio::test]
   async fn test_ping_roundtrip() {
       let socket_path = test_socket_path();

       // Start server
       ensure_server_running(&socket_path).expect("Server should start");

       // Connect
       let mut client = IpcClient::connect(&socket_path)
           .await
           .expect("Should connect");

       // Ping
       let latency = client.ping().await.expect("Ping should succeed");

       // Verify latency is reasonable (< 100ms for local IPC)
       assert!(latency < Duration::from_millis(100), "Ping too slow: {:?}", latency);

       // Cleanup
       // Note: Server will auto-shutdown after inactivity or when process exits
       cleanup_socket(&socket_path);
   }

   #[tokio::test]
   async fn test_ping_latency_under_10ms() {
       let socket_path = test_socket_path();

       ensure_server_running(&socket_path).expect("Server should start");

       let mut client = IpcClient::connect(&socket_path)
           .await
           .expect("Should connect");

       // Warm up
       let _ = client.ping().await;

       // Measure multiple pings
       let mut total = Duration::ZERO;
       let iterations = 10;

       for _ in 0..iterations {
           let latency = client.ping().await.expect("Ping should succeed");
           total += latency;
       }

       let avg = total / iterations;
       println!("Average ping latency: {:?}", avg);

       // Success criteria: average < 10ms
       assert!(avg < Duration::from_millis(10), "Average latency {:?} exceeds 10ms target", avg);

       cleanup_socket(&socket_path);
   }

   #[tokio::test]
   async fn test_connect_or_start() {
       let socket_path = test_socket_path();

       // Server not running initially
       assert!(!socket_path.exists());

       // connect_or_start should auto-start
       let mut client = IpcClient::connect_or_start(&socket_path)
           .await
           .expect("Should connect or start");

       // Verify working
       let latency = client.ping().await.expect("Ping should work");
       assert!(latency < Duration::from_secs(1));

       cleanup_socket(&socket_path);
   }

   #[tokio::test]
   async fn test_stale_socket_cleanup() {
       let socket_path = test_socket_path();

       // Create a stale socket file (not a real server)
       std::fs::write(&socket_path, "stale").expect("Create fake socket");

       // ensure_server_running should detect stale and start fresh
       ensure_server_running(&socket_path).expect("Should handle stale socket");

       // Should be able to connect now
       let client = IpcClient::connect(&socket_path).await;
       assert!(client.is_ok(), "Should connect after stale cleanup");

       cleanup_socket(&socket_path);
   }

   #[tokio::test]
   async fn test_timeout_on_no_response() {
       // This test verifies timeout behavior.
       // We can't easily simulate a non-responsive server, so we test
       // that connecting to a non-existent socket fails appropriately.

       let socket_path = PathBuf::from("/tmp/nonexistent-crystalmath-test.sock");

       let result = timeout(
           Duration::from_secs(2),
           IpcClient::connect(&socket_path)
       ).await;

       // Should fail (either timeout or connection refused)
       assert!(result.is_err() || result.unwrap().is_err());
   }
   ```

2. Ensure tests are marked with `#[ignore]` if they require Python environment:
   - Add conditional compilation or ignore attribute for CI without Python
   - Document test requirements in module doc comment
  </action>
  <verify>
```bash
cd /Users/briansquires/CRYSTAL23/crystalmath

# Integration tests compile
cargo test --test ipc_integration --no-run 2>&1 | tail -10

# Run integration tests (requires Python server)
cargo test --test ipc_integration -- --nocapture 2>&1 | tail -30
```
  </verify>
  <done>
- Integration test file exists at tests/ipc_integration.rs
- test_ping_roundtrip passes
- test_ping_latency_under_10ms verifies < 10ms target
- test_connect_or_start verifies auto-start
- test_stale_socket_cleanup verifies recovery
  </done>
</task>

</tasks>

<verification>
```bash
cd /Users/briansquires/CRYSTAL23/crystalmath

# 1. Full build
cargo build

# 2. Run integration tests
cargo test --test ipc_integration -- --nocapture

# 3. Verify ping latency meets target
cargo test --test ipc_integration test_ping_latency_under_10ms -- --nocapture 2>&1 | grep -E "Average|assert"

# 4. Manual auto-start test
rm -f /tmp/crystalmath-manual-test.sock
timeout 5 bash -c '
  # Start Rust binary that will auto-start server
  # (This would be tested via the actual TUI, manual verification)
  echo "Auto-start logic verified via integration tests"
'
```
</verification>

<success_criteria>
- `cargo test ipc` passes (all IPC tests)
- Server starts automatically when TUI launches (via ensure_server_running)
- Ping/pong roundtrip averages < 10ms
- Stale socket detection and cleanup works
- Integration tests document the IPC contract
</success_criteria>

<output>
After completion, create `.planning/phases/01-ipc-foundation/01-03-SUMMARY.md`
</output>
