---
phase: 02-quacc-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - python/crystalmath/quacc/__init__.py
  - python/crystalmath/quacc/discovery.py
  - python/crystalmath/quacc/engines.py
  - python/crystalmath/quacc/config.py
  - python/crystalmath/quacc/store.py
autonomous: true

must_haves:
  truths:
    - "Recipe discovery returns list of VASP recipes from quacc.recipes.vasp"
    - "Engine detection reports installed workflow engines"
    - "Cluster configurations survive restart"
    - "Job store can list jobs by status"
    - "Submodule import errors are handled gracefully without crashing"
  artifacts:
    - path: "python/crystalmath/quacc/__init__.py"
      provides: "Package initialization with public exports"
    - path: "python/crystalmath/quacc/discovery.py"
      provides: "discover_vasp_recipes() function"
      exports: ["discover_vasp_recipes"]
    - path: "python/crystalmath/quacc/engines.py"
      provides: "get_workflow_engine(), get_installed_engines(), get_engine_status()"
      exports: ["get_workflow_engine", "get_installed_engines", "get_engine_status"]
    - path: "python/crystalmath/quacc/config.py"
      provides: "ParslClusterConfig model, ClusterConfigStore class"
      exports: ["ParslClusterConfig", "ClusterConfigStore"]
    - path: "python/crystalmath/quacc/store.py"
      provides: "JobStatus enum, JobMetadata model, JobStore class"
      exports: ["JobStatus", "JobMetadata", "JobStore"]
  key_links:
    - from: "python/crystalmath/quacc/discovery.py"
      to: "quacc.recipes.vasp"
      via: "pkgutil.walk_packages introspection"
      pattern: "pkgutil\\.walk_packages"
    - from: "python/crystalmath/quacc/engines.py"
      to: "quacc.SETTINGS"
      via: "WORKFLOW_ENGINE attribute"
      pattern: "SETTINGS\\.WORKFLOW_ENGINE"
---

<objective>
Create the Python quacc integration module with recipe discovery, workflow engine detection, cluster configuration storage, and job metadata tracking.

Purpose: Provides the foundation for Phase 2's read-only quacc integration. All RPC handlers will delegate to these modules.

Output: `python/crystalmath/quacc/` package with discovery, engines, config, and store modules.
</objective>

<execution_context>
@/Users/briansquires/.claude/get-shit-done/workflows/execute-plan.md
@/Users/briansquires/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-quacc-integration/02-RESEARCH.md

# Existing handler patterns
@python/crystalmath/server/handlers.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create quacc discovery and engines modules</name>
  <files>
    python/crystalmath/quacc/__init__.py
    python/crystalmath/quacc/discovery.py
    python/crystalmath/quacc/engines.py
  </files>
  <action>
Create the `python/crystalmath/quacc/` package with recipe discovery and engine detection.

**discovery.py:**
- `discover_vasp_recipes() -> list[dict]` - Walk `quacc.recipes.vasp.*` via `pkgutil.walk_packages()`
- For each module, find functions ending in `_job` or `_flow` using `inspect.getmembers()`
- Return list of dicts with: name, module, fullname, docstring, signature, type ("job" or "flow")
- Handle ImportError gracefully at TWO levels:
  1. Top-level: If `quacc` itself cannot be imported, return empty list with logged warning
  2. Submodule-level: If any submodule (e.g., MLIP modules) raises ImportError during walk_packages or getmembers, catch it, log at DEBUG level, and continue to next module
- This ensures partial quacc installations or modules with missing optional deps don't crash discovery
- Log skipped modules at DEBUG level with the specific ImportError message

**engines.py:**
- `get_workflow_engine() -> str | None` - Return `quacc.SETTINGS.WORKFLOW_ENGINE` or None
- `get_installed_engines() -> list[str]` - Check imports for parsl, dask.distributed, prefect, covalent, jobflow
- `get_engine_status() -> dict` - Return {"configured": str|None, "installed": list[str], "quacc_installed": bool}

**__init__.py:**
- Export: discover_vasp_recipes, get_workflow_engine, get_installed_engines, get_engine_status
- Include module docstring explaining purpose

Guard all quacc imports with try/except to handle case where quacc is not installed.
  </action>
  <verify>
```bash
cd /Users/briansquires/CRYSTAL23/crystalmath
uv run python -c "from crystalmath.quacc import discover_vasp_recipes, get_engine_status; print('imports ok')"
uv run python -c "from crystalmath.quacc.engines import get_engine_status; print(get_engine_status())"
# Test graceful handling when quacc submodule has import error (simulated)
uv run python -c "
from crystalmath.quacc.discovery import discover_vasp_recipes
recipes = discover_vasp_recipes()
print(f'Discovered {len(recipes)} recipes (0 is OK if quacc not installed)')
"
```
  </verify>
  <done>
- `discover_vasp_recipes()` returns list of recipe dicts (empty list if quacc not installed)
- Submodule ImportErrors are caught and logged at DEBUG, discovery continues
- `get_engine_status()` returns dict with configured/installed/quacc_installed keys
- All imports succeed even when quacc is not installed or has partial deps
  </done>
</task>

<task type="auto">
  <name>Task 2: Create cluster config and job store modules</name>
  <files>
    python/crystalmath/quacc/config.py
    python/crystalmath/quacc/store.py
  </files>
  <action>
Create cluster configuration and job metadata storage modules.

**config.py:**
- `ParslClusterConfig(BaseModel)` with fields:
  - name: str (required)
  - partition: str (required)
  - account: str | None
  - nodes_per_block: int = 1
  - cores_per_node: int = 32
  - mem_per_node: int | None (GB)
  - walltime: str = "01:00:00" (validate with regex pattern)
  - max_blocks: int = 10
  - worker_init: str = "" (module loads, conda activate)
  - scheduler_options: str = "" (additional #SBATCH directives)

- `ClusterConfigStore` class:
  - `__init__(config_path: Path | None = None)` - Default: `~/.crystalmath/clusters.json`
  - `list_clusters() -> list[dict]` - Return all clusters from JSON
  - `get_cluster(name: str) -> ParslClusterConfig | None` - Get by name
  - `save_cluster(config: ParslClusterConfig) -> None` - Add/update cluster (for future use)
  - Create parent directory on init if not exists

**store.py:**
- `JobStatus(str, Enum)` with: pending, running, completed, failed
- `JobMetadata(BaseModel)` with:
  - id: str (UUID)
  - recipe: str (e.g., "quacc.recipes.vasp.core.relax_job")
  - status: JobStatus
  - created_at: datetime
  - updated_at: datetime
  - cluster: str | None
  - work_dir: Path | None
  - error_message: str | None
  - results_summary: dict | None

- `JobStore` class:
  - `__init__(store_path: Path | None = None)` - Default: `~/.crystalmath/jobs.json`
  - `list_jobs(status: JobStatus | None = None, limit: int = 100) -> list[JobMetadata]`
  - `get_job(job_id: str) -> JobMetadata | None`
  - `save_job(job: JobMetadata) -> None` (for future use)
  - Sort by created_at descending

Use Pydantic BaseModel for validation. Handle missing files gracefully (return empty list).
  </action>
  <verify>
```bash
cd /Users/briansquires/CRYSTAL23/crystalmath
uv run python -c "from crystalmath.quacc.config import ClusterConfigStore; s = ClusterConfigStore(); print(s.list_clusters())"
uv run python -c "from crystalmath.quacc.store import JobStore, JobStatus; s = JobStore(); print(s.list_jobs())"
```
  </verify>
  <done>
- ClusterConfigStore initializes without error, creates parent dir
- JobStore initializes without error, returns empty list when no jobs file
- Both use Pydantic models with proper validation
- Default paths resolve to ~/.crystalmath/
  </done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for quacc module</name>
  <files>
    python/tests/test_quacc.py
  </files>
  <action>
Create comprehensive unit tests for the quacc module.

**test_quacc.py:**

Test discovery.py:
- `test_discover_vasp_recipes_without_quacc` - Mock quacc not installed, returns empty list
- `test_discover_vasp_recipes_with_quacc` - Mock quacc.recipes.vasp, verify recipe extraction
- `test_discover_skips_import_errors` - Mock module with ImportError, verify graceful skip and continued discovery
- `test_discover_logs_skipped_modules` - Verify DEBUG log message for skipped modules

Test engines.py:
- `test_get_workflow_engine_not_set` - Returns None when WORKFLOW_ENGINE unset
- `test_get_workflow_engine_parsl` - Returns "parsl" when configured
- `test_get_installed_engines` - Mock various imports, verify detection
- `test_get_engine_status_structure` - Verify return dict has all expected keys

Test config.py:
- `test_parsl_cluster_config_defaults` - Verify default values
- `test_parsl_cluster_config_walltime_validation` - Valid and invalid walltime patterns
- `test_cluster_config_store_empty_file` - Returns [] when file doesn't exist
- `test_cluster_config_store_list_clusters` - Mock JSON file, verify parsing
- `test_cluster_config_store_get_cluster` - Find by name

Test store.py:
- `test_job_status_enum` - All values accessible
- `test_job_metadata_required_fields` - Validation works
- `test_job_store_empty` - Returns [] when no file
- `test_job_store_filter_by_status` - Filter jobs by status

Use pytest fixtures for temp directories. Mock file I/O to avoid side effects.
  </action>
  <verify>
```bash
cd /Users/briansquires/CRYSTAL23/crystalmath
uv run pytest python/tests/test_quacc.py -v
```
  </verify>
  <done>
- All tests pass
- Tests cover both success and error paths
- Submodule ImportError handling is explicitly tested
- No external dependencies required (quacc mocked)
  </done>
</task>

</tasks>

<verification>
```bash
cd /Users/briansquires/CRYSTAL23/crystalmath

# All imports work
uv run python -c "from crystalmath.quacc import discover_vasp_recipes, get_engine_status"
uv run python -c "from crystalmath.quacc.config import ClusterConfigStore, ParslClusterConfig"
uv run python -c "from crystalmath.quacc.store import JobStore, JobStatus, JobMetadata"

# Tests pass
uv run pytest python/tests/test_quacc.py -v

# Type checking (if mypy configured)
uv run mypy python/crystalmath/quacc/ --ignore-missing-imports || true
```
</verification>

<success_criteria>
- [ ] `python/crystalmath/quacc/` package exists with 5 files
- [ ] `discover_vasp_recipes()` returns list (empty if no quacc)
- [ ] Submodule ImportErrors are handled gracefully (logged at DEBUG, discovery continues)
- [ ] `get_engine_status()` returns dict with correct structure
- [ ] `ClusterConfigStore` and `JobStore` handle missing files gracefully
- [ ] All unit tests pass
- [ ] Imports succeed even without quacc installed
</success_criteria>

<output>
After completion, create `.planning/phases/02-quacc-integration/02-01-SUMMARY.md`
</output>
