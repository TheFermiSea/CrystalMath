---
phase: 02-quacc-integration
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - python/crystalmath/server/handlers/recipes.py
  - python/crystalmath/server/handlers/clusters.py
  - python/crystalmath/server/handlers/jobs.py
  - python/crystalmath/server/handlers/__init__.py
  - python/crystalmath/server/__init__.py
autonomous: true

must_haves:
  truths:
    - "recipes.list RPC returns available VASP recipes"
    - "clusters.list RPC returns configured clusters and workflow engine status"
    - "jobs.list RPC returns job metadata from local store"
  artifacts:
    - path: "python/crystalmath/server/handlers/recipes.py"
      provides: "recipes.list handler"
      exports: ["handle_recipes_list"]
    - path: "python/crystalmath/server/handlers/clusters.py"
      provides: "clusters.list handler"
      exports: ["handle_clusters_list"]
    - path: "python/crystalmath/server/handlers/jobs.py"
      provides: "jobs.list handler"
      exports: ["handle_jobs_list"]
    - path: "python/crystalmath/server/handlers/__init__.py"
      provides: "Auto-registers all handlers"
  key_links:
    - from: "python/crystalmath/server/handlers/recipes.py"
      to: "python/crystalmath/quacc/discovery.py"
      via: "discover_vasp_recipes import"
      pattern: "from crystalmath\\.quacc\\.discovery import"
    - from: "python/crystalmath/server/handlers/clusters.py"
      to: "python/crystalmath/quacc/config.py"
      via: "ClusterConfigStore import"
      pattern: "from crystalmath\\.quacc\\.config import"
    - from: "python/crystalmath/server/handlers/jobs.py"
      to: "python/crystalmath/quacc/store.py"
      via: "JobStore import"
      pattern: "from crystalmath\\.quacc\\.store import"
---

<objective>
Create JSON-RPC handlers for recipes.list, clusters.list, and jobs.list that expose quacc integration via IPC.

Purpose: Bridge between Rust TUI and Python quacc module. These handlers transform quacc data into JSON responses for the TUI.

Output: `python/crystalmath/server/handlers/` package with namespace-based handler modules.
</objective>

<execution_context>
@/Users/briansquires/.claude/get-shit-done/workflows/execute-plan.md
@/Users/briansquires/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-quacc-integration/02-RESEARCH.md
@.planning/phases/02-quacc-integration/02-01-SUMMARY.md

# Existing handler pattern
@python/crystalmath/server/handlers.py
@python/crystalmath/server/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create handlers package and recipes.list handler</name>
  <files>
    python/crystalmath/server/handlers/__init__.py
    python/crystalmath/server/handlers/recipes.py
  </files>
  <action>
Create the handlers subpackage with recipes.list handler.

**handlers/__init__.py:**
```python
"""JSON-RPC handler modules for crystalmath-server.

This package contains namespace-based handler modules. Each module
registers its handlers using the @register_handler decorator from
the parent handlers module.

Import order matters - importing this package auto-registers all handlers.
"""
from crystalmath.server import handlers  # Parent module with HANDLER_REGISTRY

# Import handler modules to trigger registration
from . import recipes
from . import clusters
from . import jobs

__all__ = ["recipes", "clusters", "jobs"]
```

**handlers/recipes.py:**
```python
"""RPC handlers for recipes.* namespace."""
from crystalmath.server.handlers import register_handler

@register_handler("recipes.list")
async def handle_recipes_list(controller, params: dict) -> dict:
    """List available quacc VASP recipes.

    Returns:
        {
            "recipes": [
                {
                    "name": "relax_job",
                    "module": "quacc.recipes.vasp.core",
                    "fullname": "quacc.recipes.vasp.core.relax_job",
                    "docstring": "Relax structure...",
                    "signature": "(atoms, ...)",
                    "type": "job"
                },
                ...
            ],
            "quacc_version": "0.11.2" | null,
            "error": null | "error message"
        }
    """
    try:
        from crystalmath.quacc.discovery import discover_vasp_recipes
        import quacc

        recipes = discover_vasp_recipes()
        return {
            "recipes": recipes,
            "quacc_version": getattr(quacc, "__version__", "unknown"),
            "error": None,
        }
    except ImportError as e:
        return {
            "recipes": [],
            "quacc_version": None,
            "error": f"quacc not available: {e}",
        }
```

Note: Keep the original `handlers.py` file intact with system.* handlers. The new handlers/ package extends the registry.
  </action>
  <verify>
```bash
cd /Users/briansquires/CRYSTAL23/crystalmath
uv run python -c "
from crystalmath.server.handlers import HANDLER_REGISTRY
# Import handlers package to register namespace handlers
import crystalmath.server.handlers as h
from crystalmath.server import handlers as handlers_pkg
print('recipes.list' in handlers_pkg.HANDLER_REGISTRY)
"
```
  </verify>
  <done>
- handlers/__init__.py exists and imports recipe module
- recipes.list registered in HANDLER_REGISTRY
- Handler returns correct structure with recipes list or error
  </done>
</task>

<task type="auto">
  <name>Task 2: Create clusters.list and jobs.list handlers</name>
  <files>
    python/crystalmath/server/handlers/clusters.py
    python/crystalmath/server/handlers/jobs.py
  </files>
  <action>
Create handlers for clusters and jobs namespaces.

**handlers/clusters.py:**
```python
"""RPC handlers for clusters.* namespace."""
from crystalmath.server.handlers import register_handler

@register_handler("clusters.list")
async def handle_clusters_list(controller, params: dict) -> dict:
    """List configured clusters and workflow engine status.

    Returns:
        {
            "clusters": [
                {
                    "name": "nersc-perlmutter",
                    "partition": "regular",
                    "account": "m1234",
                    ...
                },
                ...
            ],
            "workflow_engine": {
                "configured": "parsl" | null,
                "installed": ["parsl", "dask"],
                "quacc_installed": true | false
            }
        }
    """
    from crystalmath.quacc.engines import get_engine_status
    from crystalmath.quacc.config import ClusterConfigStore

    store = ClusterConfigStore()

    return {
        "clusters": store.list_clusters(),
        "workflow_engine": get_engine_status(),
    }
```

**handlers/jobs.py:**
```python
"""RPC handlers for jobs.* namespace (quacc job tracking)."""
from crystalmath.server.handlers import register_handler

@register_handler("jobs.list")
async def handle_jobs_list(controller, params: dict) -> dict:
    """List jobs from local metadata store.

    Params:
        status (str, optional): Filter by status ("pending", "running", etc.)
        limit (int, optional): Max results (default 100)

    Returns:
        {
            "jobs": [
                {
                    "id": "uuid",
                    "recipe": "quacc.recipes.vasp.core.relax_job",
                    "status": "running",
                    "created_at": "2026-02-02T12:00:00Z",
                    "updated_at": "2026-02-02T12:05:00Z",
                    "cluster": "nersc-perlmutter",
                    "work_dir": "/scratch/...",
                    "error_message": null,
                    "results_summary": null
                },
                ...
            ],
            "total": 42
        }
    """
    from crystalmath.quacc.store import JobStore, JobStatus

    store = JobStore()

    # Parse params
    status_str = params.get("status")
    status = JobStatus(status_str) if status_str else None
    limit = params.get("limit", 100)

    jobs = store.list_jobs(status=status, limit=limit)

    return {
        "jobs": [j.model_dump(mode="json") for j in jobs],
        "total": len(jobs),
    }
```

Update handlers/__init__.py to import clusters and jobs modules (already done in Task 1 template).
  </action>
  <verify>
```bash
cd /Users/briansquires/CRYSTAL23/crystalmath
uv run python -c "
from crystalmath.server.handlers import HANDLER_REGISTRY
# Import handlers package to register all handlers
from crystalmath.server import handlers as handlers_pkg
print('clusters.list registered:', 'clusters.list' in handlers_pkg.HANDLER_REGISTRY)
print('jobs.list registered:', 'jobs.list' in handlers_pkg.HANDLER_REGISTRY)
"
```
  </verify>
  <done>
- clusters.list registered in HANDLER_REGISTRY
- jobs.list registered in HANDLER_REGISTRY
- Both handlers return correct structure
- Status filter works for jobs.list
  </done>
</task>

<task type="auto">
  <name>Task 3: Update server to auto-import handlers package and add tests</name>
  <files>
    python/crystalmath/server/__init__.py
    python/tests/test_handlers_quacc.py
  </files>
  <action>
Update server module to auto-import handlers package and add integration tests.

**server/__init__.py update:**
Add import at the end of the file (after HANDLER_REGISTRY is defined in handlers.py):
```python
# At module level, after existing imports and before serve_forever:
# Auto-register namespace handlers
try:
    from crystalmath.server import handlers as _handlers_module
    # This import triggers handler registration via handlers/__init__.py
    import crystalmath.server.handlers  # noqa: F401
except ImportError:
    pass  # handlers package may not exist yet during development
```

**tests/test_handlers_quacc.py:**
Test the new handlers with mocked backends.

```python
"""Tests for quacc-related RPC handlers."""
import pytest
from unittest.mock import patch, MagicMock

@pytest.fixture
def mock_quacc_not_installed():
    """Mock quacc ImportError."""
    with patch.dict('sys.modules', {'quacc': None}):
        yield

@pytest.mark.asyncio
async def test_recipes_list_quacc_not_installed():
    """recipes.list returns empty list when quacc not installed."""
    from crystalmath.server.handlers import HANDLER_REGISTRY
    from crystalmath.server import handlers  # noqa

    handler = HANDLER_REGISTRY.get("recipes.list")
    assert handler is not None

    with patch('crystalmath.quacc.discovery.discover_vasp_recipes',
               side_effect=ImportError("No module named 'quacc'")):
        result = await handler(None, {})

    assert result["recipes"] == []
    assert result["quacc_version"] is None
    assert "not available" in result["error"]

@pytest.mark.asyncio
async def test_recipes_list_with_recipes():
    """recipes.list returns recipes when quacc is installed."""
    from crystalmath.server.handlers import HANDLER_REGISTRY
    from crystalmath.server import handlers  # noqa

    mock_recipes = [
        {"name": "relax_job", "module": "quacc.recipes.vasp.core", "type": "job"}
    ]

    handler = HANDLER_REGISTRY["recipes.list"]
    with patch('crystalmath.quacc.discovery.discover_vasp_recipes', return_value=mock_recipes):
        with patch('quacc.__version__', "0.11.0", create=True):
            with patch.dict('sys.modules', {'quacc': MagicMock(__version__="0.11.0")}):
                # Need to re-import to pick up mock
                import importlib
                import crystalmath.server.handlers.recipes as recipes_mod
                importlib.reload(recipes_mod)
                result = await recipes_mod.handle_recipes_list(None, {})

    assert len(result["recipes"]) == 1
    assert result["error"] is None

@pytest.mark.asyncio
async def test_clusters_list():
    """clusters.list returns clusters and engine status."""
    from crystalmath.server.handlers import HANDLER_REGISTRY
    from crystalmath.server import handlers  # noqa

    mock_clusters = [{"name": "test-cluster", "partition": "gpu"}]
    mock_status = {"configured": None, "installed": [], "quacc_installed": False}

    handler = HANDLER_REGISTRY["clusters.list"]
    with patch('crystalmath.quacc.config.ClusterConfigStore') as MockStore:
        MockStore.return_value.list_clusters.return_value = mock_clusters
        with patch('crystalmath.quacc.engines.get_engine_status', return_value=mock_status):
            result = await handler(None, {})

    assert result["clusters"] == mock_clusters
    assert result["workflow_engine"] == mock_status

@pytest.mark.asyncio
async def test_jobs_list_empty():
    """jobs.list returns empty list when no jobs."""
    from crystalmath.server.handlers import HANDLER_REGISTRY
    from crystalmath.server import handlers  # noqa

    handler = HANDLER_REGISTRY["jobs.list"]
    with patch('crystalmath.quacc.store.JobStore') as MockStore:
        MockStore.return_value.list_jobs.return_value = []
        result = await handler(None, {})

    assert result["jobs"] == []
    assert result["total"] == 0
```
  </action>
  <verify>
```bash
cd /Users/briansquires/CRYSTAL23/crystalmath
uv run pytest python/tests/test_handlers_quacc.py -v

# Verify all handlers registered
uv run python -c "
from crystalmath.server.handlers import HANDLER_REGISTRY
required = ['system.ping', 'recipes.list', 'clusters.list', 'jobs.list']
for h in required:
    assert h in HANDLER_REGISTRY, f'{h} not registered'
print('All handlers registered!')
"
```
  </verify>
  <done>
- Server auto-imports handlers package on startup
- All tests pass
- system.ping, recipes.list, clusters.list, jobs.list all registered
  </done>
</task>

</tasks>

<verification>
```bash
cd /Users/briansquires/CRYSTAL23/crystalmath

# All handlers registered
uv run python -c "
from crystalmath.server.handlers import HANDLER_REGISTRY
import crystalmath.server.handlers  # noqa
print('Registered handlers:', list(HANDLER_REGISTRY.keys()))
assert 'recipes.list' in HANDLER_REGISTRY
assert 'clusters.list' in HANDLER_REGISTRY
assert 'jobs.list' in HANDLER_REGISTRY
"

# Tests pass
uv run pytest python/tests/test_handlers_quacc.py -v

# Server starts without error
uv run crystalmath-server --help
```
</verification>

<success_criteria>
- [ ] handlers/ package created with recipes.py, clusters.py, jobs.py
- [ ] recipes.list, clusters.list, jobs.list registered in HANDLER_REGISTRY
- [ ] Server auto-imports handlers package
- [ ] All tests pass
- [ ] Handler responses match documented structure
</success_criteria>

<output>
After completion, create `.planning/phases/02-quacc-integration/02-02-SUMMARY.md`
</output>
