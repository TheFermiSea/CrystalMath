---
phase: 02-quacc-integration
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - src/models.rs
  - src/ui/recipes.rs
  - src/ui/mod.rs
  - src/app.rs
autonomous: true

must_haves:
  truths:
    - "TUI displays recipe list from recipes.list RPC"
    - "TUI displays cluster status from clusters.list RPC"
    - "Recipe browser shows recipe name, type, and docstring"
    - "Cluster status shows workflow engine info"
  artifacts:
    - path: "src/models.rs"
      provides: "Recipe, RecipesListResponse, ClusterInfo, WorkflowEngineStatus models"
      contains: "pub struct Recipe"
    - path: "src/ui/recipes.rs"
      provides: "Recipe browser UI component"
      exports: ["render_recipes"]
    - path: "src/ui/mod.rs"
      provides: "recipes module export"
      contains: "pub mod recipes"
    - path: "src/app.rs"
      provides: "Recipes tab and data loading"
      contains: "Tab::Recipes"
  key_links:
    - from: "src/ui/recipes.rs"
      to: "src/models.rs"
      via: "Recipe type import"
      pattern: "use crate::models::"
    - from: "src/app.rs"
      to: "src/ipc/client.rs"
      via: "IpcClient::call for recipes.list"
      pattern: "client\\.call.*recipes\\.list"
---

<objective>
Add Rust models for quacc API responses and create a recipe browser TUI screen with cluster status display.

Purpose: Enables users to browse available VASP recipes and see configured workflow engine status directly in the TUI.

Output: New `src/ui/recipes.rs` screen, updated models, and app integration with new Recipes tab.
</objective>

<execution_context>
@/Users/briansquires/.claude/get-shit-done/workflows/execute-plan.md
@/Users/briansquires/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-quacc-integration/02-RESEARCH.md
@.planning/phases/02-quacc-integration/02-02-SUMMARY.md

# Existing patterns
@src/models.rs
@src/app.rs
@src/ui/mod.rs
@src/ui/jobs.rs
@src/ipc/client.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Rust models for quacc API responses</name>
  <files>src/models.rs</files>
  <action>
Add models matching the Python RPC handler responses.

Add to src/models.rs:

```rust
// ==================== quacc Integration Models ====================

/// A quacc recipe entry from recipe discovery.
///
/// Matches the dict returned by `discover_vasp_recipes()` in Python.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Recipe {
    /// Function name (e.g., "relax_job")
    pub name: String,
    /// Module path (e.g., "quacc.recipes.vasp.core")
    pub module: String,
    /// Full qualified name (e.g., "quacc.recipes.vasp.core.relax_job")
    pub fullname: String,
    /// Docstring from the recipe function
    #[serde(default)]
    pub docstring: String,
    /// Function signature (e.g., "(atoms, **kwargs)")
    #[serde(default)]
    pub signature: String,
    /// Recipe type: "job" or "flow"
    #[serde(rename = "type")]
    pub recipe_type: String,
}

impl Recipe {
    /// Get short display name (just the function name).
    pub fn display_name(&self) -> &str {
        &self.name
    }

    /// Get category from module path (e.g., "core" from "quacc.recipes.vasp.core").
    pub fn category(&self) -> &str {
        self.module
            .rsplit('.')
            .next()
            .unwrap_or("unknown")
    }

    /// Check if this is a job (vs flow).
    pub fn is_job(&self) -> bool {
        self.recipe_type == "job"
    }

    /// Get first line of docstring for brief description.
    pub fn brief_description(&self) -> &str {
        self.docstring
            .lines()
            .next()
            .unwrap_or("")
            .trim()
    }
}

/// Response from recipes.list RPC call.
#[derive(Debug, Clone, Deserialize)]
pub struct RecipesListResponse {
    pub recipes: Vec<Recipe>,
    pub quacc_version: Option<String>,
    pub error: Option<String>,
}

/// Workflow engine status from engines.get_engine_status().
#[derive(Debug, Clone, Default, Deserialize)]
pub struct WorkflowEngineStatus {
    /// Currently configured engine (e.g., "parsl", "dask") or None
    pub configured: Option<String>,
    /// List of installed engine names
    #[serde(default)]
    pub installed: Vec<String>,
    /// Whether quacc package is installed
    #[serde(default)]
    pub quacc_installed: bool,
}

impl WorkflowEngineStatus {
    /// Get display string for configured engine.
    pub fn configured_display(&self) -> &str {
        self.configured.as_deref().unwrap_or("None")
    }

    /// Check if any workflow engine is available.
    pub fn has_engine(&self) -> bool {
        !self.installed.is_empty()
    }
}

/// Cluster configuration from quacc config store.
///
/// Note: This is the Parsl-style cluster config, different from
/// the existing ClusterConfig which is for SSH/SLURM direct connections.
#[derive(Debug, Clone, Default, Deserialize)]
pub struct QuaccClusterConfig {
    pub name: String,
    pub partition: String,
    #[serde(default)]
    pub account: Option<String>,
    #[serde(default = "default_nodes_per_block")]
    pub nodes_per_block: i32,
    #[serde(default = "default_cores_per_node")]
    pub cores_per_node: i32,
    #[serde(default)]
    pub mem_per_node: Option<i32>,
    #[serde(default = "default_walltime")]
    pub walltime: String,
    #[serde(default = "default_max_blocks")]
    pub max_blocks: i32,
    #[serde(default)]
    pub worker_init: String,
    #[serde(default)]
    pub scheduler_options: String,
}

fn default_nodes_per_block() -> i32 { 1 }
fn default_cores_per_node() -> i32 { 32 }
fn default_walltime() -> String { "01:00:00".to_string() }
fn default_max_blocks() -> i32 { 10 }

/// Response from clusters.list RPC call.
#[derive(Debug, Clone, Default, Deserialize)]
pub struct ClustersListResponse {
    pub clusters: Vec<QuaccClusterConfig>,
    pub workflow_engine: WorkflowEngineStatus,
}

/// Job metadata from quacc job store.
///
/// Note: This is distinct from JobStatus which is for the existing
/// TUI job tracking. This tracks quacc-submitted jobs.
#[derive(Debug, Clone, Deserialize)]
pub struct QuaccJobMetadata {
    pub id: String,
    pub recipe: String,
    pub status: String,  // "pending", "running", "completed", "failed"
    pub created_at: String,
    pub updated_at: String,
    #[serde(default)]
    pub cluster: Option<String>,
    #[serde(default)]
    pub work_dir: Option<String>,
    #[serde(default)]
    pub error_message: Option<String>,
    #[serde(default)]
    pub results_summary: Option<serde_json::Value>,
}

/// Response from jobs.list RPC call (quacc jobs).
#[derive(Debug, Clone, Default, Deserialize)]
pub struct QuaccJobsListResponse {
    pub jobs: Vec<QuaccJobMetadata>,
    pub total: usize,
}
```

Add tests for the new models:

```rust
#[cfg(test)]
mod quacc_model_tests {
    use super::*;

    #[test]
    fn test_recipe_deserialize() {
        let json = r#"{
            "name": "relax_job",
            "module": "quacc.recipes.vasp.core",
            "fullname": "quacc.recipes.vasp.core.relax_job",
            "docstring": "Relax a structure.\n\nMore details here.",
            "signature": "(atoms, **kwargs)",
            "type": "job"
        }"#;
        let recipe: Recipe = serde_json::from_str(json).unwrap();
        assert_eq!(recipe.name, "relax_job");
        assert_eq!(recipe.category(), "core");
        assert!(recipe.is_job());
        assert_eq!(recipe.brief_description(), "Relax a structure.");
    }

    #[test]
    fn test_recipes_list_response() {
        let json = r#"{
            "recipes": [],
            "quacc_version": "0.11.0",
            "error": null
        }"#;
        let response: RecipesListResponse = serde_json::from_str(json).unwrap();
        assert!(response.recipes.is_empty());
        assert_eq!(response.quacc_version, Some("0.11.0".to_string()));
    }

    #[test]
    fn test_workflow_engine_status() {
        let json = r#"{
            "configured": "parsl",
            "installed": ["parsl", "dask"],
            "quacc_installed": true
        }"#;
        let status: WorkflowEngineStatus = serde_json::from_str(json).unwrap();
        assert_eq!(status.configured_display(), "parsl");
        assert!(status.has_engine());
    }

    #[test]
    fn test_clusters_list_response() {
        let json = r#"{
            "clusters": [{"name": "test", "partition": "gpu"}],
            "workflow_engine": {"quacc_installed": false}
        }"#;
        let response: ClustersListResponse = serde_json::from_str(json).unwrap();
        assert_eq!(response.clusters.len(), 1);
        assert!(!response.workflow_engine.quacc_installed);
    }
}
```
  </action>
  <verify>
```bash
cd /Users/briansquires/CRYSTAL23/crystalmath
cargo test quacc_model -- --nocapture
```
  </verify>
  <done>
- Recipe, RecipesListResponse, WorkflowEngineStatus models added
- QuaccClusterConfig, ClustersListResponse models added
- QuaccJobMetadata, QuaccJobsListResponse models added
- All model tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Create recipe browser UI component</name>
  <files>
    src/ui/recipes.rs
    src/ui/mod.rs
  </files>
  <action>
Create a recipe browser screen following existing UI patterns.

**src/ui/recipes.rs:**
```rust
//! Recipe browser UI component.
//!
//! Displays available quacc VASP recipes from the recipes.list RPC call.
//! Shows recipe name, category, type (job/flow), and brief description.

use ratatui::{
    layout::{Constraint, Direction, Layout, Rect},
    style::{Color, Modifier, Style},
    text::{Line, Span},
    widgets::{Block, Borders, List, ListItem, ListState, Paragraph, Wrap},
    Frame,
};

use crate::models::{Recipe, WorkflowEngineStatus};

/// State for the recipe browser.
#[derive(Debug, Default)]
pub struct RecipeBrowserState {
    /// Currently selected recipe index.
    pub selected: usize,
    /// List widget state for scrolling.
    pub list_state: ListState,
    /// Loaded recipes (empty until fetched).
    pub recipes: Vec<Recipe>,
    /// Workflow engine status.
    pub engine_status: WorkflowEngineStatus,
    /// Error message if load failed.
    pub error: Option<String>,
    /// Whether data is currently loading.
    pub loading: bool,
}

impl RecipeBrowserState {
    /// Select previous recipe.
    pub fn previous(&mut self) {
        if self.recipes.is_empty() {
            return;
        }
        self.selected = self.selected.saturating_sub(1);
        self.list_state.select(Some(self.selected));
    }

    /// Select next recipe.
    pub fn next(&mut self) {
        if self.recipes.is_empty() {
            return;
        }
        self.selected = (self.selected + 1).min(self.recipes.len().saturating_sub(1));
        self.list_state.select(Some(self.selected));
    }

    /// Get currently selected recipe.
    pub fn selected_recipe(&self) -> Option<&Recipe> {
        self.recipes.get(self.selected)
    }

    /// Update with loaded data.
    pub fn set_data(&mut self, recipes: Vec<Recipe>, engine_status: WorkflowEngineStatus, error: Option<String>) {
        self.recipes = recipes;
        self.engine_status = engine_status;
        self.error = error;
        self.loading = false;
        if !self.recipes.is_empty() {
            self.list_state.select(Some(0));
        }
    }
}

/// Render the recipe browser screen.
pub fn render(frame: &mut Frame, area: Rect, state: &mut RecipeBrowserState) {
    // Layout: sidebar (recipe list) | main (recipe details)
    let chunks = Layout::default()
        .direction(Direction::Horizontal)
        .constraints([Constraint::Percentage(40), Constraint::Percentage(60)])
        .split(area);

    render_recipe_list(frame, chunks[0], state);
    render_recipe_details(frame, chunks[1], state);
}

fn render_recipe_list(frame: &mut Frame, area: Rect, state: &mut RecipeBrowserState) {
    // Vertical layout: engine status bar | recipe list
    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints([Constraint::Length(3), Constraint::Min(0)])
        .split(area);

    // Engine status bar
    let engine_text = if state.engine_status.quacc_installed {
        format!(
            "Engine: {} | Installed: {}",
            state.engine_status.configured_display(),
            if state.engine_status.installed.is_empty() {
                "none".to_string()
            } else {
                state.engine_status.installed.join(", ")
            }
        )
    } else {
        "quacc not installed".to_string()
    };

    let engine_style = if state.engine_status.quacc_installed {
        Style::default().fg(Color::Green)
    } else {
        Style::default().fg(Color::Red)
    };

    let engine_block = Paragraph::new(engine_text)
        .style(engine_style)
        .block(Block::default().borders(Borders::ALL).title("Workflow Engine"));
    frame.render_widget(engine_block, chunks[0]);

    // Recipe list
    if state.loading {
        let loading = Paragraph::new("Loading recipes...")
            .block(Block::default().borders(Borders::ALL).title("Recipes"));
        frame.render_widget(loading, chunks[1]);
        return;
    }

    if let Some(ref error) = state.error {
        let error_para = Paragraph::new(error.as_str())
            .style(Style::default().fg(Color::Red))
            .block(Block::default().borders(Borders::ALL).title("Recipes"));
        frame.render_widget(error_para, chunks[1]);
        return;
    }

    let items: Vec<ListItem> = state
        .recipes
        .iter()
        .enumerate()
        .map(|(i, recipe)| {
            let type_icon = if recipe.is_job() { "J" } else { "F" };
            let style = if i == state.selected {
                Style::default()
                    .fg(Color::Yellow)
                    .add_modifier(Modifier::BOLD)
            } else {
                Style::default()
            };

            ListItem::new(Line::from(vec![
                Span::styled(format!("[{}] ", type_icon), Style::default().fg(Color::Cyan)),
                Span::styled(&recipe.name, style),
                Span::styled(format!(" ({})", recipe.category()), Style::default().fg(Color::DarkGray)),
            ]))
        })
        .collect();

    let list = List::new(items)
        .block(Block::default().borders(Borders::ALL).title(format!(
            "Recipes ({} total)",
            state.recipes.len()
        )))
        .highlight_style(Style::default().bg(Color::DarkGray));

    frame.render_stateful_widget(list, chunks[1], &mut state.list_state);
}

fn render_recipe_details(frame: &mut Frame, area: Rect, state: &RecipeBrowserState) {
    let Some(recipe) = state.selected_recipe() else {
        let empty = Paragraph::new("Select a recipe to view details")
            .block(Block::default().borders(Borders::ALL).title("Details"));
        frame.render_widget(empty, area);
        return;
    };

    let content = vec![
        Line::from(vec![
            Span::styled("Name: ", Style::default().fg(Color::Cyan)),
            Span::raw(&recipe.name),
        ]),
        Line::from(vec![
            Span::styled("Module: ", Style::default().fg(Color::Cyan)),
            Span::raw(&recipe.module),
        ]),
        Line::from(vec![
            Span::styled("Type: ", Style::default().fg(Color::Cyan)),
            Span::raw(&recipe.recipe_type),
        ]),
        Line::from(vec![
            Span::styled("Signature: ", Style::default().fg(Color::Cyan)),
            Span::raw(&recipe.signature),
        ]),
        Line::from(""),
        Line::from(Span::styled("Description:", Style::default().fg(Color::Cyan).add_modifier(Modifier::BOLD))),
        Line::from(""),
    ];

    // Add docstring lines
    let mut lines = content;
    for line in recipe.docstring.lines() {
        lines.push(Line::from(line));
    }

    let details = Paragraph::new(lines)
        .block(Block::default().borders(Borders::ALL).title("Recipe Details"))
        .wrap(Wrap { trim: false });

    frame.render_widget(details, area);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_recipe_browser_state_navigation() {
        let mut state = RecipeBrowserState::default();
        state.recipes = vec![
            Recipe {
                name: "relax_job".to_string(),
                module: "quacc.recipes.vasp.core".to_string(),
                fullname: "quacc.recipes.vasp.core.relax_job".to_string(),
                docstring: "Relax".to_string(),
                signature: "()".to_string(),
                recipe_type: "job".to_string(),
            },
            Recipe {
                name: "static_job".to_string(),
                module: "quacc.recipes.vasp.core".to_string(),
                fullname: "quacc.recipes.vasp.core.static_job".to_string(),
                docstring: "Static".to_string(),
                signature: "()".to_string(),
                recipe_type: "job".to_string(),
            },
        ];
        state.list_state.select(Some(0));

        state.next();
        assert_eq!(state.selected, 1);

        state.next();
        assert_eq!(state.selected, 1); // Can't go past end

        state.previous();
        assert_eq!(state.selected, 0);

        state.previous();
        assert_eq!(state.selected, 0); // Can't go past start
    }
}
```

**Update src/ui/mod.rs:**
Add `pub mod recipes;` to the module list.
  </action>
  <verify>
```bash
cd /Users/briansquires/CRYSTAL23/crystalmath
cargo build 2>&1 | head -30
cargo test ui::recipes -- --nocapture
```
  </verify>
  <done>
- src/ui/recipes.rs created with RecipeBrowserState and render function
- src/ui/mod.rs exports recipes module
- Recipe list shows name, type icon, and category
- Details pane shows full recipe info
- Navigation tests pass
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate recipe browser into app</name>
  <files>src/app.rs</files>
  <action>
Add Recipes tab to the app and wire up data loading.

**Update src/app.rs:**

1. Add Tab variant:
```rust
// In Tab enum:
pub enum Tab {
    Jobs,
    Editor,
    Results,
    Log,
    Materials,
    Clusters,
    SlurmQueue,
    VaspInput,
    Workflows,
    Recipes,  // New tab
}
```

2. Add RecipeBrowserState to App:
```rust
// In App struct:
pub recipe_browser: RecipeBrowserState,
```

3. Initialize in App::new():
```rust
recipe_browser: RecipeBrowserState::default(),
```

4. Add tab display name:
```rust
// In tab display logic:
Tab::Recipes => "Recipes",
```

5. Add render case:
```rust
// In render match:
Tab::Recipes => {
    ui::recipes::render(frame, main_chunks[1], &mut self.recipe_browser);
}
```

6. Add input handling:
```rust
// In handle_input for Tab::Recipes:
Tab::Recipes => {
    match key.code {
        KeyCode::Up | KeyCode::Char('k') => self.recipe_browser.previous(),
        KeyCode::Down | KeyCode::Char('j') => self.recipe_browser.next(),
        KeyCode::Char('r') | KeyCode::Char('R') => {
            // Trigger reload
            self.load_recipes();
        }
        _ => {}
    }
}
```

7. Add data loading method:
```rust
impl App {
    /// Load recipes from IPC.
    pub async fn load_recipes(&mut self) {
        self.recipe_browser.loading = true;
        self.mark_dirty();

        // This will be called from the async context
        // For now, set up the loading state
    }

    /// Handle recipes.list response.
    pub fn handle_recipes_response(&mut self, response: RecipesListResponse, clusters_response: ClustersListResponse) {
        self.recipe_browser.set_data(
            response.recipes,
            clusters_response.workflow_engine,
            response.error,
        );
        self.mark_dirty();
    }
}
```

8. Add keyboard shortcut for tab (if not all keys used):
The tab can be accessed via number keys or cycling through tabs.
  </action>
  <verify>
```bash
cd /Users/briansquires/CRYSTAL23/crystalmath
cargo build 2>&1 | head -50
cargo test app -- --nocapture
```
  </verify>
  <done>
- Tab::Recipes variant added
- RecipeBrowserState integrated into App
- Render case routes to ui::recipes::render
- Input handling for navigation (j/k, arrows)
- Data loading methods stubbed for async integration
  </done>
</task>

</tasks>

<verification>
```bash
cd /Users/briansquires/CRYSTAL23/crystalmath

# Build succeeds
cargo build

# All tests pass
cargo test models -- --nocapture
cargo test ui::recipes -- --nocapture

# Run TUI (manual verification - can exit with 'q')
# cargo run --release
```
</verification>

<success_criteria>
- [ ] Recipe, RecipesListResponse models deserialize correctly
- [ ] WorkflowEngineStatus, QuaccClusterConfig models deserialize correctly
- [ ] Recipe browser renders with list and details panes
- [ ] Tab::Recipes accessible in app
- [ ] Navigation (j/k, arrows) works in recipe list
- [ ] All tests pass
- [ ] Build succeeds without warnings
</success_criteria>

<output>
After completion, create `.planning/phases/02-quacc-integration/02-03-SUMMARY.md`
</output>
