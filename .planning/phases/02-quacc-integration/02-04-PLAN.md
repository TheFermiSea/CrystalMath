---
phase: 02-quacc-integration
plan: 04
type: execute
wave: 4
depends_on: ["02-03"]
files_modified:
  - tests/quacc_integration.rs
  - src/app.rs
  - src/main.rs
  - python/crystalmath/server/__init__.py
autonomous: false

must_haves:
  truths:
    - "Rust TUI can call recipes.list via IPC and display results"
    - "Rust TUI can call clusters.list via IPC and display engine status"
    - "Integration tests verify end-to-end RPC flow"
    - "TUI displays error gracefully when quacc not installed"
    - "Recipes tab triggers data load on first access"
  artifacts:
    - path: "tests/quacc_integration.rs"
      provides: "Integration tests for quacc RPC handlers"
  key_links:
    - from: "tests/quacc_integration.rs"
      to: "src/ipc/client.rs"
      via: "IpcClient::call"
      pattern: "client\\.call"
    - from: "src/app.rs"
      to: "src/ipc/client.rs"
      via: "Async IPC call for recipes/clusters"
      pattern: "recipes\\.list|clusters\\.list"
    - from: "src/main.rs"
      to: "src/app.rs"
      via: "Recipe loading triggered on tab change"
      pattern: "AppTab::Recipes.*request_load_recipes"
---

<objective>
Create integration tests for quacc RPC handlers and complete the TUI data loading loop with async IPC calls.

Purpose: Verifies end-to-end flow from Rust TUI through IPC to Python handlers. Ensures graceful handling of missing quacc.

Output: Integration test file and complete async data loading in app.
</objective>

<execution_context>
@/Users/briansquires/.claude/get-shit-done/workflows/execute-plan.md
@/Users/briansquires/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-quacc-integration/02-03-SUMMARY.md

# Existing integration test patterns
@tests/ipc_integration.rs
@src/ipc/client.rs
@src/app.rs
@src/main.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create quacc integration tests</name>
  <files>tests/quacc_integration.rs</files>
  <action>
Create integration tests that verify the RPC handlers work end-to-end.

**tests/quacc_integration.rs:**
```rust
//! Integration tests for quacc RPC handlers.
//!
//! These tests verify the Rust TUI can communicate with Python
//! quacc handlers via IPC. Tests run against a real server instance.

use std::path::PathBuf;
use std::time::Duration;

use anyhow::Result;
use serde_json::json;
use tokio::time::timeout;

use crystalmath::ipc::{IpcClient, default_socket_path, ensure_server_running};
use crystalmath::models::{RecipesListResponse, ClustersListResponse, QuaccJobsListResponse};

/// Helper to get a unique socket path for tests.
fn test_socket_path(test_name: &str) -> PathBuf {
    let runtime_dir = std::env::var("XDG_RUNTIME_DIR")
        .map(PathBuf::from)
        .unwrap_or_else(|_| std::env::temp_dir());
    runtime_dir.join(format!("crystalmath-test-{}-{}.sock", test_name, std::process::id()))
}

/// Ensure server is running and return connected client.
async fn setup_test_client(socket_path: &PathBuf) -> Result<IpcClient> {
    ensure_server_running(socket_path)?;
    let client = IpcClient::connect_with_retry(socket_path, 5).await?;
    Ok(client)
}

/// Clean up test socket after test.
fn cleanup_socket(socket_path: &PathBuf) {
    let _ = std::fs::remove_file(socket_path);
}

#[tokio::test]
async fn test_recipes_list_returns_valid_response() {
    let socket = test_socket_path("recipes_list");

    let result = async {
        let mut client = setup_test_client(&socket).await?;

        let response = client.call("recipes.list", json!({})).await?;
        let parsed: RecipesListResponse = serde_json::from_value(response)?;

        // Should have a valid structure regardless of quacc installation
        assert!(parsed.error.is_none() || parsed.recipes.is_empty());

        // If quacc is installed, we should have some recipes
        if parsed.quacc_version.is_some() && parsed.error.is_none() {
            assert!(!parsed.recipes.is_empty(), "quacc installed but no recipes found");
            // Verify recipe structure
            let recipe = &parsed.recipes[0];
            assert!(!recipe.name.is_empty());
            assert!(recipe.fullname.contains("quacc.recipes"));
            assert!(recipe.recipe_type == "job" || recipe.recipe_type == "flow");
        }

        Ok::<_, anyhow::Error>(())
    }
    .await;

    cleanup_socket(&socket);
    result.expect("Test failed");
}

#[tokio::test]
async fn test_recipes_list_handles_no_quacc() {
    // This test verifies graceful degradation when quacc is not installed.
    // The response should include an error message but not fail.
    let socket = test_socket_path("recipes_no_quacc");

    let result = async {
        let mut client = setup_test_client(&socket).await?;

        let response = client.call("recipes.list", json!({})).await?;
        let parsed: RecipesListResponse = serde_json::from_value(response)?;

        // Either we have recipes (quacc installed) or we have an error (not installed)
        if parsed.quacc_version.is_none() {
            // quacc not installed - error should explain why
            assert!(
                parsed.error.is_some() || parsed.recipes.is_empty(),
                "Expected error or empty recipes when quacc not installed"
            );
        }

        Ok::<_, anyhow::Error>(())
    }
    .await;

    cleanup_socket(&socket);
    result.expect("Test failed");
}

#[tokio::test]
async fn test_clusters_list_returns_valid_response() {
    let socket = test_socket_path("clusters_list");

    let result = async {
        let mut client = setup_test_client(&socket).await?;

        let response = client.call("clusters.list", json!({})).await?;
        let parsed: ClustersListResponse = serde_json::from_value(response)?;

        // Should always have workflow_engine status
        // Even if quacc not installed, we should get the status structure
        // The installed list may be empty, but the structure should be valid

        // Verify structure
        // configured may be None, installed may be empty, quacc_installed may be false
        // All are valid states

        Ok::<_, anyhow::Error>(())
    }
    .await;

    cleanup_socket(&socket);
    result.expect("Test failed");
}

#[tokio::test]
async fn test_jobs_list_returns_empty_initially() {
    let socket = test_socket_path("jobs_list");

    let result = async {
        let mut client = setup_test_client(&socket).await?;

        let response = client.call("jobs.list", json!({})).await?;
        let parsed: QuaccJobsListResponse = serde_json::from_value(response)?;

        // Initially should be empty (no jobs submitted yet)
        assert_eq!(parsed.total, 0);
        assert!(parsed.jobs.is_empty());

        Ok::<_, anyhow::Error>(())
    }
    .await;

    cleanup_socket(&socket);
    result.expect("Test failed");
}

#[tokio::test]
async fn test_jobs_list_with_status_filter() {
    let socket = test_socket_path("jobs_list_filter");

    let result = async {
        let mut client = setup_test_client(&socket).await?;

        // Filter by status - should not error even with no jobs
        let response = client.call("jobs.list", json!({"status": "running"})).await?;
        let parsed: QuaccJobsListResponse = serde_json::from_value(response)?;

        // Should return empty list (no running jobs)
        assert_eq!(parsed.total, 0);

        Ok::<_, anyhow::Error>(())
    }
    .await;

    cleanup_socket(&socket);
    result.expect("Test failed");
}

#[tokio::test]
async fn test_jobs_list_with_limit() {
    let socket = test_socket_path("jobs_list_limit");

    let result = async {
        let mut client = setup_test_client(&socket).await?;

        let response = client.call("jobs.list", json!({"limit": 10})).await?;
        let parsed: QuaccJobsListResponse = serde_json::from_value(response)?;

        // Limit should be respected (though with 0 jobs, this is trivially true)
        assert!(parsed.jobs.len() <= 10);

        Ok::<_, anyhow::Error>(())
    }
    .await;

    cleanup_socket(&socket);
    result.expect("Test failed");
}

#[tokio::test]
async fn test_all_quacc_handlers_registered() {
    // Verify all expected handlers are callable
    let socket = test_socket_path("all_handlers");

    let result = async {
        let mut client = setup_test_client(&socket).await?;

        // Verify each handler exists and returns valid JSON
        let handlers = vec![
            ("recipes.list", json!({})),
            ("clusters.list", json!({})),
            ("jobs.list", json!({})),
        ];

        for (method, params) in handlers {
            let response = timeout(
                Duration::from_secs(5),
                client.call(method, params.clone()),
            )
            .await
            .expect(&format!("{} timed out", method))
            .expect(&format!("{} failed", method));

            // Should be valid JSON object
            assert!(response.is_object(), "{} did not return object", method);
        }

        Ok::<_, anyhow::Error>(())
    }
    .await;

    cleanup_socket(&socket);
    result.expect("Test failed");
}
```

Note: Tests assume the Python server can be started. If quacc is not installed, tests should still pass with appropriate error handling.
  </action>
  <verify>
```bash
cd /Users/briansquires/CRYSTAL23/crystalmath
cargo test quacc_integration -- --test-threads=1 --nocapture
```
  </verify>
  <done>
- Integration tests created for recipes.list, clusters.list, jobs.list
- Tests verify response structure matches Rust models
- Tests handle case where quacc is not installed
- All tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Complete async data loading in app with event loop wiring</name>
  <files>src/app.rs, src/main.rs</files>
  <action>
Wire up the async data loading from IPC to the recipe browser state.

**Pattern to follow:** The codebase uses a 60fps event loop in main.rs that:
1. Calls `app.poll_bridge_responses()` each frame to receive async results
2. Uses `BridgeRequestKind` enum to track pending requests
3. Uses `pending_request_id` to correlate responses

**Step 1: Add recipe browser state to App (src/app.rs)**

Add fields to the App struct:
```rust
// ===== Recipe Browser State =====
/// Recipe browser state for quacc recipes tab
pub recipe_browser: RecipeBrowserState,

/// Request ID for current recipe fetch (to ignore stale responses)
pub recipe_request_id: usize,
```

Add RecipeBrowserState struct (in state.rs or inline):
```rust
/// State for the quacc recipe browser tab
pub struct RecipeBrowserState {
    /// Whether recipes are currently being loaded
    pub loading: bool,
    /// Whether recipes have been loaded at least once
    pub loaded: bool,
    /// List of discovered recipes
    pub recipes: Vec<RecipeInfo>,
    /// Workflow engine status from clusters.list
    pub workflow_engine: Option<WorkflowEngineStatus>,
    /// Error message if loading failed
    pub error: Option<String>,
    /// Selected recipe index
    pub selected_index: Option<usize>,
}

impl RecipeBrowserState {
    pub fn new() -> Self {
        Self {
            loading: false,
            loaded: false,
            recipes: Vec::new(),
            workflow_engine: None,
            error: None,
            selected_index: None,
        }
    }

    pub fn set_data(
        &mut self,
        recipes: Vec<RecipeInfo>,
        engine: Option<WorkflowEngineStatus>,
        error: Option<String>,
    ) {
        self.loading = false;
        self.loaded = true;
        self.recipes = recipes;
        self.workflow_engine = engine;
        self.error = error;
        if !self.recipes.is_empty() && self.selected_index.is_none() {
            self.selected_index = Some(0);
        }
    }
}
```

**Step 2: Add request method to App (src/app.rs)**

```rust
impl App {
    /// Request recipe list load via IPC (non-blocking).
    ///
    /// Sends recipes.list and clusters.list RPC calls.
    /// Results delivered via poll_bridge_responses().
    pub fn request_load_recipes(&mut self) {
        // Skip if already loading or already loaded
        if self.recipe_browser.loading || self.recipe_browser.loaded {
            return;
        }

        self.recipe_browser.loading = true;
        self.recipe_request_id = self.next_request_id();

        // Use the JSON-RPC bridge pattern (BridgeRequest::Rpc variant)
        let rpc_request = crate::bridge::JsonRpcRequest {
            jsonrpc: "2.0".to_string(),
            method: "recipes.list".to_string(),
            params: Some(serde_json::json!({})),
            id: self.recipe_request_id,
        };

        if let Err(e) = self.bridge.request_rpc(rpc_request, self.recipe_request_id) {
            self.recipe_browser.loading = false;
            self.recipe_browser.error = Some(format!("Failed to request recipes: {}", e));
        }

        self.mark_dirty();
    }
}
```

**Step 3: Handle response in poll_bridge_responses (src/app.rs)**

In the existing `poll_bridge_responses` method, add a match arm for RpcResult that checks recipe_request_id:

```rust
BridgeResponse::RpcResult { request_id, result } => {
    // Check if this is a recipe list response
    if request_id == self.recipe_request_id && self.recipe_browser.loading {
        self.recipe_browser.loading = false;
        match result {
            Ok(rpc_response) => {
                if let Some(data) = rpc_response.result {
                    // Parse RecipesListResponse from data
                    match serde_json::from_value::<RecipesListResponse>(data) {
                        Ok(response) => {
                            self.recipe_browser.set_data(
                                response.recipes,
                                None, // workflow_engine loaded separately
                                response.error,
                            );
                        }
                        Err(e) => {
                            self.recipe_browser.error = Some(format!("Parse error: {}", e));
                        }
                    }
                } else if let Some(err) = rpc_response.error {
                    self.recipe_browser.error = Some(format!("{}: {}", err.code, err.message));
                }
            }
            Err(e) => {
                self.recipe_browser.error = Some(e.to_string());
            }
        }
        self.mark_dirty();
    }
    // ... existing cluster handling ...
}
```

**Step 4: Wire tab change to recipe loading (src/main.rs)**

In the run_app function, after the tab change handlers but before `app.tick()`, add:

```rust
// Load recipes when Recipes tab is first accessed
if app.current_tab == app::AppTab::Recipes
    && !app.recipe_browser.loaded
    && !app.recipe_browser.loading
{
    app.request_load_recipes();
}
```

This follows the pattern used for `try_refresh_jobs()` and `try_refresh_clusters()` at startup.

**Step 5: Add refresh on 'r' key (src/main.rs)**

In handle_tab_input, add a Recipes tab match arm (or add to existing if present):

```rust
app::AppTab::Recipes => {
    match key.code {
        KeyCode::Up | KeyCode::Char('k') => app.select_prev_recipe(),
        KeyCode::Down | KeyCode::Char('j') => app.select_next_recipe(),
        KeyCode::Char('r') => {
            // Force refresh by resetting loaded state
            app.recipe_browser.loaded = false;
            app.request_load_recipes();
        }
        _ => {}
    }
}
```
  </action>
  <verify>
```bash
cd /Users/briansquires/CRYSTAL23/crystalmath
cargo build
cargo test app -- --nocapture
# Verify event loop wiring compiles
grep -n "request_load_recipes" src/main.rs src/app.rs
```
  </verify>
  <done>
- RecipeBrowserState struct added to App with loading/loaded/recipes/error fields
- request_load_recipes() method sends RPC via bridge
- poll_bridge_responses() handles RpcResult for recipe_request_id
- main.rs event loop triggers recipe loading when Recipes tab first accessed
- 'r' key forces refresh in Recipes tab
- Error handling included for all paths
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete quacc integration with recipe browser TUI that displays VASP recipes from quacc via IPC.
  </what-built>
  <how-to-verify>
1. Start the TUI:
   ```bash
   cd /Users/briansquires/CRYSTAL23/crystalmath
   cargo run --release
   ```

2. Navigate to the Recipes tab (use number keys or Tab to cycle)

3. Verify:
   - [ ] Workflow engine status bar shows at top (green if quacc installed, red if not)
   - [ ] Recipe list shows available VASP recipes (or "quacc not installed" message)
   - [ ] Pressing j/k or arrows navigates the recipe list
   - [ ] Details pane on right shows recipe info (name, module, docstring)
   - [ ] Pressing 'r' refreshes the recipe list

4. If quacc IS installed:
   - [ ] Recipes like "relax_job", "static_job" appear in list
   - [ ] quacc version shown in status or response
   - [ ] At least 5-10 recipes visible

5. If quacc is NOT installed:
   - [ ] Error message displayed gracefully
   - [ ] TUI does not crash
   - [ ] Clear indication that quacc needs to be installed

6. Exit with 'q'
  </how-to-verify>
  <resume-signal>Type "approved" if recipe browser works correctly, or describe issues</resume-signal>
</task>

</tasks>

<verification>
```bash
cd /Users/briansquires/CRYSTAL23/crystalmath

# Integration tests pass
cargo test quacc_integration -- --test-threads=1 --nocapture

# All Rust tests pass
cargo test

# Python tests pass
uv run pytest python/tests/test_quacc.py python/tests/test_handlers_quacc.py -v

# Build succeeds
cargo build --release

# Verify event loop wiring exists
grep -n "AppTab::Recipes" src/main.rs | grep -q "request_load_recipes" && echo "Event loop wiring OK"

# TUI runs (manual verification)
# cargo run --release
```
</verification>

<success_criteria>
- [ ] Integration tests verify recipes.list, clusters.list, jobs.list
- [ ] Tests pass even when quacc is not installed
- [ ] App loads recipe data via IPC when Recipes tab selected
- [ ] Event loop in main.rs triggers request_load_recipes() on tab change
- [ ] TUI displays recipe list or appropriate error message
- [ ] Human verification confirms UI works correctly
</success_criteria>

<output>
After completion, create `.planning/phases/02-quacc-integration/02-04-SUMMARY.md`
</output>
