---
phase: 02-quacc-integration
plan: 04
type: execute
wave: 4
depends_on: ["02-02", "02-03"]
files_modified:
  - tests/quacc_integration.rs
  - src/app.rs
  - python/crystalmath/server/__init__.py
autonomous: false

must_haves:
  truths:
    - "Rust TUI can call recipes.list via IPC and display results"
    - "Rust TUI can call clusters.list via IPC and display engine status"
    - "Integration tests verify end-to-end RPC flow"
    - "TUI displays error gracefully when quacc not installed"
  artifacts:
    - path: "tests/quacc_integration.rs"
      provides: "Integration tests for quacc RPC handlers"
  key_links:
    - from: "tests/quacc_integration.rs"
      to: "src/ipc/client.rs"
      via: "IpcClient::call"
      pattern: "client\\.call"
    - from: "src/app.rs"
      to: "src/ipc/client.rs"
      via: "Async IPC call for recipes/clusters"
      pattern: "recipes\\.list|clusters\\.list"
---

<objective>
Create integration tests for quacc RPC handlers and complete the TUI data loading loop with async IPC calls.

Purpose: Verifies end-to-end flow from Rust TUI through IPC to Python handlers. Ensures graceful handling of missing quacc.

Output: Integration test file and complete async data loading in app.
</objective>

<execution_context>
@/Users/briansquires/.claude/get-shit-done/workflows/execute-plan.md
@/Users/briansquires/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-quacc-integration/02-02-SUMMARY.md
@.planning/phases/02-quacc-integration/02-03-SUMMARY.md

# Existing integration test patterns
@tests/ipc_integration.rs
@src/ipc/client.rs
@src/app.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create quacc integration tests</name>
  <files>tests/quacc_integration.rs</files>
  <action>
Create integration tests that verify the RPC handlers work end-to-end.

**tests/quacc_integration.rs:**
```rust
//! Integration tests for quacc RPC handlers.
//!
//! These tests verify the Rust TUI can communicate with Python
//! quacc handlers via IPC. Tests run against a real server instance.

use std::path::PathBuf;
use std::time::Duration;

use anyhow::Result;
use serde_json::json;
use tokio::time::timeout;

use crystalmath::ipc::{IpcClient, default_socket_path, ensure_server_running};
use crystalmath::models::{RecipesListResponse, ClustersListResponse, QuaccJobsListResponse};

/// Helper to get a unique socket path for tests.
fn test_socket_path(test_name: &str) -> PathBuf {
    let runtime_dir = std::env::var("XDG_RUNTIME_DIR")
        .map(PathBuf::from)
        .unwrap_or_else(|_| std::env::temp_dir());
    runtime_dir.join(format!("crystalmath-test-{}-{}.sock", test_name, std::process::id()))
}

/// Ensure server is running and return connected client.
async fn setup_test_client(socket_path: &PathBuf) -> Result<IpcClient> {
    ensure_server_running(socket_path)?;
    let client = IpcClient::connect_with_retry(socket_path, 5).await?;
    Ok(client)
}

/// Clean up test socket after test.
fn cleanup_socket(socket_path: &PathBuf) {
    let _ = std::fs::remove_file(socket_path);
}

#[tokio::test]
async fn test_recipes_list_returns_valid_response() {
    let socket = test_socket_path("recipes_list");

    let result = async {
        let mut client = setup_test_client(&socket).await?;

        let response = client.call("recipes.list", json!({})).await?;
        let parsed: RecipesListResponse = serde_json::from_value(response)?;

        // Should have a valid structure regardless of quacc installation
        assert!(parsed.error.is_none() || parsed.recipes.is_empty());

        // If quacc is installed, we should have some recipes
        if parsed.quacc_version.is_some() && parsed.error.is_none() {
            assert!(!parsed.recipes.is_empty(), "quacc installed but no recipes found");
            // Verify recipe structure
            let recipe = &parsed.recipes[0];
            assert!(!recipe.name.is_empty());
            assert!(recipe.fullname.contains("quacc.recipes"));
            assert!(recipe.recipe_type == "job" || recipe.recipe_type == "flow");
        }

        Ok::<_, anyhow::Error>(())
    }
    .await;

    cleanup_socket(&socket);
    result.expect("Test failed");
}

#[tokio::test]
async fn test_recipes_list_handles_no_quacc() {
    // This test verifies graceful degradation when quacc is not installed.
    // The response should include an error message but not fail.
    let socket = test_socket_path("recipes_no_quacc");

    let result = async {
        let mut client = setup_test_client(&socket).await?;

        let response = client.call("recipes.list", json!({})).await?;
        let parsed: RecipesListResponse = serde_json::from_value(response)?;

        // Either we have recipes (quacc installed) or we have an error (not installed)
        if parsed.quacc_version.is_none() {
            // quacc not installed - error should explain why
            assert!(
                parsed.error.is_some() || parsed.recipes.is_empty(),
                "Expected error or empty recipes when quacc not installed"
            );
        }

        Ok::<_, anyhow::Error>(())
    }
    .await;

    cleanup_socket(&socket);
    result.expect("Test failed");
}

#[tokio::test]
async fn test_clusters_list_returns_valid_response() {
    let socket = test_socket_path("clusters_list");

    let result = async {
        let mut client = setup_test_client(&socket).await?;

        let response = client.call("clusters.list", json!({})).await?;
        let parsed: ClustersListResponse = serde_json::from_value(response)?;

        // Should always have workflow_engine status
        // Even if quacc not installed, we should get the status structure
        // The installed list may be empty, but the structure should be valid

        // Verify structure
        // configured may be None, installed may be empty, quacc_installed may be false
        // All are valid states

        Ok::<_, anyhow::Error>(())
    }
    .await;

    cleanup_socket(&socket);
    result.expect("Test failed");
}

#[tokio::test]
async fn test_jobs_list_returns_empty_initially() {
    let socket = test_socket_path("jobs_list");

    let result = async {
        let mut client = setup_test_client(&socket).await?;

        let response = client.call("jobs.list", json!({})).await?;
        let parsed: QuaccJobsListResponse = serde_json::from_value(response)?;

        // Initially should be empty (no jobs submitted yet)
        assert_eq!(parsed.total, 0);
        assert!(parsed.jobs.is_empty());

        Ok::<_, anyhow::Error>(())
    }
    .await;

    cleanup_socket(&socket);
    result.expect("Test failed");
}

#[tokio::test]
async fn test_jobs_list_with_status_filter() {
    let socket = test_socket_path("jobs_list_filter");

    let result = async {
        let mut client = setup_test_client(&socket).await?;

        // Filter by status - should not error even with no jobs
        let response = client.call("jobs.list", json!({"status": "running"})).await?;
        let parsed: QuaccJobsListResponse = serde_json::from_value(response)?;

        // Should return empty list (no running jobs)
        assert_eq!(parsed.total, 0);

        Ok::<_, anyhow::Error>(())
    }
    .await;

    cleanup_socket(&socket);
    result.expect("Test failed");
}

#[tokio::test]
async fn test_jobs_list_with_limit() {
    let socket = test_socket_path("jobs_list_limit");

    let result = async {
        let mut client = setup_test_client(&socket).await?;

        let response = client.call("jobs.list", json!({"limit": 10})).await?;
        let parsed: QuaccJobsListResponse = serde_json::from_value(response)?;

        // Limit should be respected (though with 0 jobs, this is trivially true)
        assert!(parsed.jobs.len() <= 10);

        Ok::<_, anyhow::Error>(())
    }
    .await;

    cleanup_socket(&socket);
    result.expect("Test failed");
}

#[tokio::test]
async fn test_all_quacc_handlers_registered() {
    // Verify all expected handlers are callable
    let socket = test_socket_path("all_handlers");

    let result = async {
        let mut client = setup_test_client(&socket).await?;

        // Verify each handler exists and returns valid JSON
        let handlers = vec![
            ("recipes.list", json!({})),
            ("clusters.list", json!({})),
            ("jobs.list", json!({})),
        ];

        for (method, params) in handlers {
            let response = timeout(
                Duration::from_secs(5),
                client.call(method, params.clone()),
            )
            .await
            .expect(&format!("{} timed out", method))
            .expect(&format!("{} failed", method));

            // Should be valid JSON object
            assert!(response.is_object(), "{} did not return object", method);
        }

        Ok::<_, anyhow::Error>(())
    }
    .await;

    cleanup_socket(&socket);
    result.expect("Test failed");
}
```

Note: Tests assume the Python server can be started. If quacc is not installed, tests should still pass with appropriate error handling.
  </action>
  <verify>
```bash
cd /Users/briansquires/CRYSTAL23/crystalmath
cargo test quacc_integration -- --test-threads=1 --nocapture
```
  </verify>
  <done>
- Integration tests created for recipes.list, clusters.list, jobs.list
- Tests verify response structure matches Rust models
- Tests handle case where quacc is not installed
- All tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Complete async data loading in app</name>
  <files>src/app.rs</files>
  <action>
Wire up the async data loading from IPC to the recipe browser state.

**Update src/app.rs:**

Add async methods that call IPC and update state:

```rust
impl App {
    /// Load recipes and cluster info via IPC.
    ///
    /// This should be called when the Recipes tab is first accessed
    /// or when the user presses 'r' to refresh.
    pub async fn load_recipes_data(&mut self, client: &mut IpcClient) -> Result<(), String> {
        use crate::models::{RecipesListResponse, ClustersListResponse};

        self.recipe_browser.loading = true;

        // Fetch recipes
        let recipes_result = client
            .call("recipes.list", serde_json::json!({}))
            .await
            .map_err(|e| e.to_string())?;

        let recipes_response: RecipesListResponse = serde_json::from_value(recipes_result)
            .map_err(|e| format!("Failed to parse recipes response: {}", e))?;

        // Fetch cluster info (for workflow engine status)
        let clusters_result = client
            .call("clusters.list", serde_json::json!({}))
            .await
            .map_err(|e| e.to_string())?;

        let clusters_response: ClustersListResponse = serde_json::from_value(clusters_result)
            .map_err(|e| format!("Failed to parse clusters response: {}", e))?;

        // Update state
        self.recipe_browser.set_data(
            recipes_response.recipes,
            clusters_response.workflow_engine,
            recipes_response.error,
        );

        Ok(())
    }
}
```

In the main event loop (main.rs), add logic to load recipes when tab is selected:

```rust
// In event loop, when Tab::Recipes is selected and not yet loaded:
if app.current_tab == Tab::Recipes && app.recipe_browser.recipes.is_empty() && !app.recipe_browser.loading {
    if let Some(ref mut client) = ipc_client {
        app.recipe_browser.loading = true;
        // Spawn async task to load data
        // This depends on your event loop architecture
    }
}
```

The exact integration depends on the existing event loop pattern. Check main.rs for the current async handling pattern and follow it.
  </action>
  <verify>
```bash
cd /Users/briansquires/CRYSTAL23/crystalmath
cargo build
cargo test app -- --nocapture
```
  </verify>
  <done>
- load_recipes_data async method added to App
- Method calls recipes.list and clusters.list via IPC
- State is updated with parsed responses
- Error handling included
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete quacc integration with recipe browser TUI that displays VASP recipes from quacc via IPC.
  </what-built>
  <how-to-verify>
1. Start the TUI:
   ```bash
   cd /Users/briansquires/CRYSTAL23/crystalmath
   cargo run --release
   ```

2. Navigate to the Recipes tab (use number keys or Tab to cycle)

3. Verify:
   - [ ] Workflow engine status bar shows at top (green if quacc installed, red if not)
   - [ ] Recipe list shows available VASP recipes (or "quacc not installed" message)
   - [ ] Pressing j/k or arrows navigates the recipe list
   - [ ] Details pane on right shows recipe info (name, module, docstring)
   - [ ] Pressing 'r' refreshes the recipe list

4. If quacc IS installed:
   - [ ] Recipes like "relax_job", "static_job" appear in list
   - [ ] quacc version shown in status or response
   - [ ] At least 5-10 recipes visible

5. If quacc is NOT installed:
   - [ ] Error message displayed gracefully
   - [ ] TUI does not crash
   - [ ] Clear indication that quacc needs to be installed

6. Exit with 'q'
  </how-to-verify>
  <resume-signal>Type "approved" if recipe browser works correctly, or describe issues</resume-signal>
</task>

</tasks>

<verification>
```bash
cd /Users/briansquires/CRYSTAL23/crystalmath

# Integration tests pass
cargo test quacc_integration -- --test-threads=1 --nocapture

# All Rust tests pass
cargo test

# Python tests pass
uv run pytest python/tests/test_quacc.py python/tests/test_handlers_quacc.py -v

# Build succeeds
cargo build --release

# TUI runs (manual verification)
# cargo run --release
```
</verification>

<success_criteria>
- [ ] Integration tests verify recipes.list, clusters.list, jobs.list
- [ ] Tests pass even when quacc is not installed
- [ ] App loads recipe data via IPC when Recipes tab selected
- [ ] TUI displays recipe list or appropriate error message
- [ ] Human verification confirms UI works correctly
</success_criteria>

<output>
After completion, create `.planning/phases/02-quacc-integration/02-04-SUMMARY.md`
</output>
