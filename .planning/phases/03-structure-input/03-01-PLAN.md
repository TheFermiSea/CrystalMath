# Plan 03-01: Python VASP Input Utilities

## Goal
Create Python utilities for generating complete VASP input files (POSCAR, INCAR, KPOINTS) from structures, enabling the Materials Project → VASP pipeline.

## Context
- Structure reading exists in `pymatgen_bridge.py` (POSCAR, CIF, Materials Project)
- `VASPInputFiles` dataclass exists in `tui/src/core/codes/vasp.py`
- Need high-level API for generating INCAR, KPOINTS from structures
- quacc uses ASE calculators which need VASP inputs

## Tasks

### 1. Add POSCAR generation wrapper
**File**: `python/crystalmath/integrations/pymatgen_bridge.py`

```python
def structure_to_poscar(structure: Structure, comment: str = "") -> str:
    """Convert pymatgen Structure to POSCAR text format.

    Args:
        structure: pymatgen Structure object
        comment: Optional comment line (default: formula)

    Returns:
        POSCAR file content as string
    """
    from pymatgen.io.vasp import Poscar
    poscar = Poscar(structure, comment=comment or structure.formula)
    return poscar.get_str()
```

### 2. Create VASP input generator module
**File**: `python/crystalmath/vasp/__init__.py` (new module)

```python
"""VASP input file generation utilities."""
from .incar import IncarBuilder, IncarPreset
from .kpoints import KpointsBuilder, KpointsMesh
from .generator import VaspInputGenerator
```

### 3. INCAR builder with presets
**File**: `python/crystalmath/vasp/incar.py`

```python
from enum import Enum
from dataclasses import dataclass, field
from typing import Optional, Dict, Any

class IncarPreset(Enum):
    """Standard INCAR presets for common calculations."""
    RELAX = "relax"          # Geometry optimization
    STATIC = "static"        # Single-point energy
    BANDS = "bands"          # Band structure (non-SCF)
    DOS = "dos"              # Density of states
    CONVERGENCE = "convergence"  # Convergence testing

@dataclass
class IncarBuilder:
    """Build INCAR files with sensible defaults."""

    # Electronic convergence
    encut: Optional[float] = None      # Plane-wave cutoff (eV)
    ediff: float = 1e-6                # SCF convergence
    nelm: int = 100                    # Max SCF iterations

    # Smearing
    ismear: int = 0                    # 0=Gaussian, 1=MP, -5=tetrahedron
    sigma: float = 0.05                # Smearing width

    # Ionic relaxation
    ibrion: int = -1                   # -1=static, 2=CG, 1=quasi-Newton
    isif: int = 2                      # 2=ions, 3=ions+cell
    nsw: int = 0                       # Ionic steps (0=static)
    ediffg: float = -0.01              # Force convergence (eV/Å)

    # Output
    lwave: bool = False                # Write WAVECAR
    lcharg: bool = False               # Write CHGCAR

    # Parallelization
    ncore: int = 4                     # Cores per band

    # Additional parameters
    extra: Dict[str, Any] = field(default_factory=dict)

    @classmethod
    def from_preset(cls, preset: IncarPreset, **overrides) -> "IncarBuilder":
        """Create builder from preset configuration."""
        presets = {
            IncarPreset.RELAX: {"ibrion": 2, "isif": 2, "nsw": 100},
            IncarPreset.STATIC: {"ibrion": -1, "nsw": 0},
            IncarPreset.BANDS: {"ibrion": -1, "nsw": 0, "icharg": 11},
            IncarPreset.DOS: {"ibrion": -1, "nsw": 0, "ismear": -5, "nedos": 2001},
            IncarPreset.CONVERGENCE: {"ibrion": -1, "nsw": 0, "lwave": True},
        }
        params = presets.get(preset, {})
        params.update(overrides)
        return cls(**params)

    def to_string(self) -> str:
        """Generate INCAR file content."""
        lines = ["# VASP INCAR - Generated by CrystalMath", ""]

        # Electronic
        lines.append("# Electronic convergence")
        if self.encut:
            lines.append(f"ENCUT = {self.encut}")
        lines.append(f"EDIFF = {self.ediff}")
        lines.append(f"NELM = {self.nelm}")
        lines.append("")

        # Smearing
        lines.append("# Smearing")
        lines.append(f"ISMEAR = {self.ismear}")
        lines.append(f"SIGMA = {self.sigma}")
        lines.append("")

        # Ionic (only if relaxation)
        if self.nsw > 0:
            lines.append("# Ionic relaxation")
            lines.append(f"IBRION = {self.ibrion}")
            lines.append(f"ISIF = {self.isif}")
            lines.append(f"NSW = {self.nsw}")
            lines.append(f"EDIFFG = {self.ediffg}")
            lines.append("")

        # Output
        lines.append("# Output control")
        lines.append(f"LWAVE = .{'TRUE' if self.lwave else 'FALSE'}.")
        lines.append(f"LCHARG = .{'TRUE' if self.lcharg else 'FALSE'}.")
        lines.append("")

        # Parallelization
        lines.append("# Parallelization")
        lines.append(f"NCORE = {self.ncore}")

        # Extra parameters
        if self.extra:
            lines.append("")
            lines.append("# Additional parameters")
            for key, value in self.extra.items():
                if isinstance(value, bool):
                    value = f".{'TRUE' if value else 'FALSE'}."
                lines.append(f"{key.upper()} = {value}")

        return "\n".join(lines)
```

### 4. KPOINTS generator
**File**: `python/crystalmath/vasp/kpoints.py`

```python
from dataclasses import dataclass
from typing import Tuple, Optional, List
import numpy as np

@dataclass
class KpointsMesh:
    """Monkhorst-Pack k-point mesh specification."""
    mesh: Tuple[int, int, int]
    shift: Tuple[float, float, float] = (0.0, 0.0, 0.0)

    def to_string(self) -> str:
        """Generate KPOINTS file content."""
        lines = [
            "Automatic mesh",
            "0",  # Automatic generation
            "Monkhorst-Pack",
            f"{self.mesh[0]}  {self.mesh[1]}  {self.mesh[2]}",
            f"{self.shift[0]}  {self.shift[1]}  {self.shift[2]}",
        ]
        return "\n".join(lines)

@dataclass
class KpointsBuilder:
    """Build KPOINTS files with automatic density calculation."""

    @staticmethod
    def from_density(structure, kppra: int = 1000) -> KpointsMesh:
        """Generate mesh from k-point density (k-points per reciprocal atom).

        Args:
            structure: pymatgen Structure
            kppra: k-points per reciprocal atom (default 1000)

        Returns:
            KpointsMesh with appropriate density
        """
        # Get reciprocal lattice lengths
        lattice = structure.lattice
        lengths = lattice.reciprocal_lattice.abc

        # Number of atoms
        natoms = len(structure)

        # Target total k-points
        target_kpts = kppra / natoms

        # Distribute proportionally to reciprocal lengths
        ratio = np.array(lengths) / min(lengths)
        base = (target_kpts / np.prod(ratio)) ** (1/3)
        mesh = tuple(max(1, int(round(base * r))) for r in ratio)

        return KpointsMesh(mesh=mesh)

    @staticmethod
    def gamma_centered(ka: int, kb: int, kc: int) -> KpointsMesh:
        """Create Gamma-centered mesh."""
        return KpointsMesh(mesh=(ka, kb, kc), shift=(0.0, 0.0, 0.0))

    @staticmethod
    def for_slab(structure, kppra: int = 1000) -> KpointsMesh:
        """Generate mesh appropriate for slab (1 k-point in c direction)."""
        mesh = KpointsBuilder.from_density(structure, kppra)
        # Use 1 k-point perpendicular to slab (assumes c is normal)
        return KpointsMesh(mesh=(mesh.mesh[0], mesh.mesh[1], 1))
```

### 5. High-level VASP input generator
**File**: `python/crystalmath/vasp/generator.py`

```python
from dataclasses import dataclass
from typing import Optional, Dict, Any
from pathlib import Path

from pymatgen.core import Structure

from .incar import IncarBuilder, IncarPreset
from .kpoints import KpointsBuilder, KpointsMesh

@dataclass
class VaspInputs:
    """Complete VASP input file set."""
    poscar: str
    incar: str
    kpoints: str
    potcar_symbols: list[str]  # Element symbols (POTCAR must be provided by user)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to JSON-serializable dict."""
        return {
            "poscar": self.poscar,
            "incar": self.incar,
            "kpoints": self.kpoints,
            "potcar_symbols": self.potcar_symbols,
        }

class VaspInputGenerator:
    """Generate complete VASP inputs from structure."""

    def __init__(
        self,
        structure: Structure,
        preset: IncarPreset = IncarPreset.STATIC,
        encut: Optional[float] = None,
        kppra: int = 1000,
        **incar_overrides,
    ):
        self.structure = structure
        self.preset = preset
        self.encut = encut or self._estimate_encut()
        self.kppra = kppra
        self.incar_overrides = incar_overrides

    def _estimate_encut(self) -> float:
        """Estimate reasonable ENCUT based on elements.

        Uses 1.3x max ENMAX from POTCAR recommendations.
        Falls back to 520 eV if unknown.
        """
        # Rough ENMAX values for common elements
        enmax_table = {
            "H": 250, "C": 400, "N": 400, "O": 400, "F": 400,
            "Si": 245, "P": 255, "S": 280, "Cl": 262,
            "Ti": 178, "V": 193, "Cr": 227, "Mn": 270, "Fe": 268,
            "Co": 268, "Ni": 270, "Cu": 295, "Zn": 277,
            "Mo": 225, "W": 224,
            "Li": 140, "Na": 102, "K": 117, "Mg": 200, "Ca": 118,
            "Al": 240,
        }

        elements = [str(s) for s in self.structure.species]
        max_enmax = max(enmax_table.get(e, 400) for e in set(elements))
        return max_enmax * 1.3  # 30% buffer

    def generate(self) -> VaspInputs:
        """Generate all VASP input files."""
        from crystalmath.integrations.pymatgen_bridge import structure_to_poscar

        # POSCAR
        poscar = structure_to_poscar(self.structure)

        # INCAR
        incar_builder = IncarBuilder.from_preset(
            self.preset,
            encut=self.encut,
            **self.incar_overrides,
        )
        incar = incar_builder.to_string()

        # KPOINTS
        kpoints_mesh = KpointsBuilder.from_density(self.structure, self.kppra)
        kpoints = kpoints_mesh.to_string()

        # POTCAR symbols (user must provide actual POTCAR)
        potcar_symbols = list(dict.fromkeys(
            str(s) for s in self.structure.species
        ))

        return VaspInputs(
            poscar=poscar,
            incar=incar,
            kpoints=kpoints,
            potcar_symbols=potcar_symbols,
        )
```

### 6. Add ASE to dependencies
**File**: `python/pyproject.toml`

Add to `[project.optional-dependencies]`:
```toml
vasp = [
    "pymatgen>=2024.1.1",
    "ase>=3.22.0",
]
```

### 7. Unit tests
**File**: `python/tests/test_vasp_generator.py`

Test cases:
- IncarBuilder.from_preset() for each preset
- KpointsBuilder.from_density() produces valid mesh
- VaspInputGenerator.generate() returns complete inputs
- POSCAR output is valid
- ENCUT estimation works for various elements

## Success Criteria
- [ ] `structure_to_poscar()` generates valid POSCAR text
- [ ] `IncarBuilder` produces valid INCAR for all presets
- [ ] `KpointsBuilder.from_density()` calculates appropriate mesh
- [ ] `VaspInputGenerator.generate()` returns complete input set
- [ ] All unit tests pass

## Dependencies
- Phase 2 complete (quacc integration)
- pymatgen installed
