# Plan 04-01: Python Job Submission Core

---
phase: 04-job-submission
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - python/crystalmath/quacc/potcar.py
  - python/crystalmath/quacc/runner.py
  - python/crystalmath/quacc/parsl_runner.py
  - python/crystalmath/quacc/covalent_runner.py
  - python/crystalmath/quacc/__init__.py
  - python/crystalmath/server/handlers/jobs.py
  - python/tests/test_job_runner.py
autonomous: true

must_haves:
  truths:
    - "POTCAR validation rejects missing pseudopotentials before job submission"
    - "Job submission returns unique job_id for tracking"
    - "Job status can be polled without blocking"
    - "Job cancellation attempts to stop running jobs"
  artifacts:
    - path: "python/crystalmath/quacc/potcar.py"
      provides: "POTCAR path detection and element validation"
      exports: ["validate_potcars", "get_potcar_path"]
    - path: "python/crystalmath/quacc/runner.py"
      provides: "JobRunner ABC and factory"
      exports: ["JobRunner", "JobState", "get_runner"]
    - path: "python/crystalmath/quacc/parsl_runner.py"
      provides: "Parsl-based job execution"
      exports: ["ParslRunner"]
    - path: "python/crystalmath/quacc/covalent_runner.py"
      provides: "Covalent-based job execution"
      exports: ["CovalentRunner"]
    - path: "python/crystalmath/server/handlers/jobs.py"
      provides: "jobs.submit, jobs.status, jobs.cancel RPC handlers"
      contains: "register_handler"
  key_links:
    - from: "python/crystalmath/server/handlers/jobs.py"
      to: "python/crystalmath/quacc/runner.py"
      via: "get_runner() call"
      pattern: "from crystalmath\\.quacc\\.runner import"
    - from: "python/crystalmath/quacc/runner.py"
      to: "python/crystalmath/quacc/parsl_runner.py"
      via: "factory dispatch"
      pattern: "ParslRunner\\(\\)"
---

<objective>
Build the Python backend for job submission and status tracking via quacc workflow engines.

Purpose: Enable submitting VASP calculations through Parsl or Covalent, with POTCAR validation to catch configuration errors before jobs run.

Output: POTCAR validation module, JobRunner abstraction with Parsl/Covalent implementations, and RPC handlers for jobs.submit, jobs.status, jobs.cancel.
</objective>

<execution_context>
@/Users/briansquires/.claude/get-shit-done/workflows/execute-plan.md
@/Users/briansquires/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-job-submission/04-RESEARCH.md
@python/crystalmath/quacc/store.py
@python/crystalmath/quacc/engines.py
@python/crystalmath/server/handlers/jobs.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: POTCAR Validation Module</name>
  <files>python/crystalmath/quacc/potcar.py</files>
  <action>
Create POTCAR validation utilities:

1. `get_potcar_path() -> Path | None`: Get POTCAR directory from:
   - `VASP_PP_PATH` environment variable
   - quacc SETTINGS.VASP_PP_PATH (if quacc installed)
   Return None if neither set.

2. `validate_potcars(elements: set[str]) -> tuple[bool, str | None]`:
   - Get POTCAR path, return error if not set
   - Check for PBE directory (potpaw_PBE* or PBE*)
   - For each element, check element directory exists (e.g., Si, Si_sv)
   - Return (True, None) if all found, (False, error_message) if missing

Use Path for filesystem operations, handle ImportError for quacc gracefully.
  </action>
  <verify>
```bash
cd /Users/briansquires/CRYSTAL23/crystalmath
uv run python -c "from crystalmath.quacc.potcar import validate_potcars; print(validate_potcars({'Si', 'O'}))"
```
  </verify>
  <done>validate_potcars() returns (False, error_message) when VASP_PP_PATH not set, and (True, None) when valid path with elements exists</done>
</task>

<task type="auto">
  <name>Task 2: JobRunner Abstraction and Implementations</name>
  <files>
    python/crystalmath/quacc/runner.py
    python/crystalmath/quacc/parsl_runner.py
    python/crystalmath/quacc/covalent_runner.py
    python/crystalmath/quacc/__init__.py
  </files>
  <action>
Create the JobRunner abstraction layer:

**runner.py:**
```python
from abc import ABC, abstractmethod
from enum import Enum
from typing import Any
import uuid

class JobState(str, Enum):
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"

class JobRunner(ABC):
    """Abstract base for workflow engine runners."""

    @abstractmethod
    def submit(self, recipe_fullname: str, atoms: Any, cluster_name: str, **kwargs) -> str:
        """Submit job, return job_id (UUID string)."""
        pass

    @abstractmethod
    def get_status(self, job_id: str) -> JobState:
        """Get current job state (non-blocking)."""
        pass

    @abstractmethod
    def get_result(self, job_id: str) -> dict | None:
        """Get result dict if complete, None if still running, {"error": str} if failed."""
        pass

    @abstractmethod
    def cancel(self, job_id: str) -> bool:
        """Attempt to cancel job. Returns True if cancellation was requested."""
        pass

def get_runner(engine: str) -> JobRunner:
    """Factory to get runner for configured engine."""
    if engine == "parsl":
        from crystalmath.quacc.parsl_runner import ParslRunner
        return ParslRunner()
    elif engine == "covalent":
        from crystalmath.quacc.covalent_runner import CovalentRunner
        return CovalentRunner()
    else:
        raise ValueError(f"Unsupported workflow engine: {engine}")
```

**parsl_runner.py:**
- Store futures in `_futures: dict[str, Any]`
- `submit()`: Import recipe dynamically, call recipe(atoms, **kwargs), store future, return UUID
- `get_status()`: Check `future.done()`, if done check for exception
- `get_result()`: Call `future.result()` if done
- `cancel()`: Call `future.cancel()` if exists

**covalent_runner.py:**
- Store dispatch IDs in `_dispatch_ids: dict[str, str]`
- `submit()`: Create @ct.lattice wrapper, dispatch, return UUID
- `get_status()`: Call `ct.get_result(dispatch_id, wait=False)`, map status
- `get_result()`: Get result from Covalent
- `cancel()`: Call `ct.cancel()` API

Update __init__.py to export: JobRunner, JobState, get_runner
  </action>
  <verify>
```bash
cd /Users/briansquires/CRYSTAL23/crystalmath
uv run python -c "from crystalmath.quacc.runner import JobRunner, JobState, get_runner; print(JobState.PENDING.value)"
```
  </verify>
  <done>JobRunner ABC and factory function work, ParslRunner and CovalentRunner can be imported (but require their dependencies)</done>
</task>

<task type="auto">
  <name>Task 3: RPC Handlers for Job Operations</name>
  <files>python/crystalmath/server/handlers/jobs.py</files>
  <action>
Extend jobs.py with three new handlers:

**jobs.submit handler:**
- Params: recipe (str), structure (dict or POSCAR str), cluster (str optional), params (dict optional)
- Check workflow engine configured (get_workflow_engine)
- Parse structure with `_parse_structure()` helper (ASE read from StringIO or Atoms(**dict))
- Call validate_potcars() with element set, return error if invalid
- Get runner via get_runner(engine)
- Call runner.submit()
- Create JobMetadata with job_id, save to JobStore
- Return {"job_id": ..., "status": "pending", "error": None}

**jobs.status handler:**
- Params: job_id (str)
- Load JobMetadata from JobStore
- If terminal state (completed/failed), return cached status
- Otherwise poll runner.get_status()
- Update JobMetadata if status changed
- If completed, fetch runner.get_result() and summarize
- Return {"job_id": ..., "status": ..., "error": ..., "result": ...}

**jobs.cancel handler:**
- Params: job_id (str)
- Get runner, call runner.cancel()
- Update JobMetadata to cancelled if successful
- Return {"job_id": ..., "cancelled": bool}

Helper function `_parse_structure(structure_data)`:
- If str: use `ase.io.read(StringIO(data), format="vasp")`
- If dict: use `ase.Atoms(**data)`
- Raise ValueError for unknown format

Helper function `_summarize_result(result: dict) -> dict`:
- Extract energy_ev from result["results"]["energy"]
- Calculate max_force_ev_ang from result["results"]["forces"]
- Get formula from result["formula_pretty"]
- Get work_dir from result["dir_name"]
  </action>
  <verify>
```bash
cd /Users/briansquires/CRYSTAL23/crystalmath
uv run python -c "from crystalmath.server.handlers.jobs import handle_jobs_submit, handle_jobs_status, handle_jobs_cancel; print('Handlers imported')"
```
  </verify>
  <done>jobs.submit, jobs.status, jobs.cancel handlers registered and callable</done>
</task>

</tasks>

<verification>
```bash
cd /Users/briansquires/CRYSTAL23/crystalmath

# All modules import without error
uv run python -c "
from crystalmath.quacc.potcar import validate_potcars
from crystalmath.quacc.runner import JobRunner, JobState, get_runner
from crystalmath.server.handlers.jobs import handle_jobs_submit
print('All imports successful')
"

# Unit tests pass
uv run pytest python/tests/test_job_runner.py -v
```
</verification>

<success_criteria>
- [ ] POTCAR validation detects missing `VASP_PP_PATH`
- [ ] JobRunner ABC defines submit/get_status/get_result/cancel interface
- [ ] ParslRunner and CovalentRunner implement the interface
- [ ] get_runner() factory returns appropriate runner for engine
- [ ] jobs.submit handler validates POTCARs before submission
- [ ] jobs.status handler polls runner non-blockingly
- [ ] jobs.cancel handler attempts cancellation
- [ ] All new code has unit tests
</success_criteria>

<output>
After completion, create `.planning/phases/04-job-submission/04-01-SUMMARY.md`
</output>
