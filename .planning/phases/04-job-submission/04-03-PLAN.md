# Plan 04-03: Job Status Polling and Display

---
phase: 04-job-submission
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/app.rs
  - src/main.rs
  - src/ui/jobs.rs
  - src/models.rs
autonomous: true

must_haves:
  truths:
    - "Active jobs update status automatically without user action"
    - "Job status changes are visible in job table (PENDING -> RUNNING -> COMPLETE)"
    - "Failed jobs show error message in details"
    - "Completed jobs show results summary (energy, forces)"
  artifacts:
    - path: "src/app.rs"
      provides: "Status polling loop, job update logic"
      contains: "poll_job_statuses"
    - path: "src/ui/jobs.rs"
      provides: "Progress indicators, status display"
      contains: "render_job_status"
    - path: "src/models.rs"
      provides: "QuaccJobStatus enum for display"
      contains: "QuaccJobStatus"
  key_links:
    - from: "src/main.rs"
      to: "src/app.rs"
      via: "poll_job_statuses() in event loop"
      pattern: "poll_job_statuses"
    - from: "src/app.rs"
      to: "IPC jobs.status"
      via: "JSON-RPC call for each active job"
      pattern: "jobs\\.status"
---

<objective>
Implement automatic job status polling to keep the TUI synchronized with actual job states on the workflow engine.

Purpose: Users need real-time feedback on job progress without manual refresh. Jobs transition through PENDING -> RUNNING -> COMPLETED/FAILED.

Output: Polling loop in app, status updates in job table, progress display, error display for failed jobs.
</objective>

<execution_context>
@/Users/briansquires/.claude/get-shit-done/workflows/execute-plan.md
@/Users/briansquires/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-job-submission/04-RESEARCH.md
@src/app.rs
@src/models.rs
@src/ui/jobs.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Polling Infrastructure to App</name>
  <files>src/app.rs</files>
  <action>
Add job status polling to App:

**New fields in App struct:**
```rust
/// Timestamp of last job status poll
last_job_poll: std::time::Instant,
/// Interval between polls (30 seconds)
poll_interval: std::time::Duration,
/// Pending status requests (job_id -> request_id)
pending_status_requests: HashMap<String, usize>,
/// Next request ID for status polls
status_request_counter: usize,
```

Initialize in `App::new()`:
```rust
last_job_poll: std::time::Instant::now(),
poll_interval: std::time::Duration::from_secs(30),
pending_status_requests: HashMap::new(),
status_request_counter: 0,
```

**Add poll_job_statuses() method:**
```rust
pub fn poll_job_statuses(&mut self) {
    // Only poll if enough time has passed
    if self.last_job_poll.elapsed() < self.poll_interval {
        return;
    }

    // Get jobs in non-terminal states from quacc_jobs
    let active_jobs: Vec<String> = self.quacc_jobs
        .iter()
        .filter(|j| j.status != "completed" && j.status != "failed" && j.status != "cancelled")
        .map(|j| j.id.clone())
        .collect();

    if active_jobs.is_empty() {
        return;
    }

    // Send status request for each active job
    for job_id in active_jobs {
        // Skip if we already have a pending request for this job
        if self.pending_status_requests.contains_key(&job_id) {
            continue;
        }

        self.status_request_counter += 1;
        let request_id = self.status_request_counter;

        // Send JSON-RPC request: jobs.status with {"job_id": job_id}
        if let Some(ref mut bridge) = self.bridge {
            let params = serde_json::json!({"job_id": job_id.clone()});
            bridge.send_rpc_request(request_id, "jobs.status", params);
            self.pending_status_requests.insert(job_id, request_id);
        }
    }

    self.last_job_poll = std::time::Instant::now();
}
```

**In poll_bridge_responses(), add handler for status responses:**
```rust
// Check if this is a status poll response
if let Some(job_id) = self.pending_status_requests.iter()
    .find(|(_, &rid)| rid == request_id)
    .map(|(jid, _)| jid.clone())
{
    self.pending_status_requests.remove(&job_id);

    if let Ok(status_resp) = serde_json::from_value::<JobStatusResponse>(result.clone()) {
        self.update_job_from_status(status_resp);
    }
}
```

**Add update_job_from_status() method:**
```rust
fn update_job_from_status(&mut self, status: JobStatusResponse) {
    if let Some(job) = self.quacc_jobs.iter_mut().find(|j| j.id == status.job_id) {
        let old_status = job.status.clone();
        job.status = status.status.clone();
        job.error_message = status.error;

        // Update results_summary if completed
        if status.status == "completed" {
            if let Some(result) = status.result {
                job.results_summary = Some(serde_json::to_value(&result).unwrap_or_default());
            }
        }

        // Log status change
        if old_status != job.status {
            tracing::info!("Job {} status: {} -> {}", job.id, old_status, job.status);
        }
    }
}
```
  </action>
  <verify>
```bash
cd /Users/briansquires/CRYSTAL23/crystalmath
cargo check
```
  </verify>
  <done>App has poll_job_statuses() that sends status requests for active jobs every 30 seconds</done>
</task>

<task type="auto">
  <name>Task 2: Integrate Polling into Event Loop</name>
  <files>src/main.rs</files>
  <action>
Add job status polling to the main event loop.

In the main event loop (after poll_bridge_responses):
```rust
// Poll job statuses periodically
app.poll_job_statuses();
```

This should be called on every loop iteration, but poll_job_statuses() internally checks the time interval so it won't spam requests.

Consider adding a visual indicator when polling is happening (optional):
- Flash a status bar indicator briefly when poll completes
- Or just update the job table silently

Note: The 30-second interval is configurable in App::new(). For testing, can be reduced temporarily.
  </action>
  <verify>
```bash
cd /Users/briansquires/CRYSTAL23/crystalmath
cargo build
```
  </verify>
  <done>Event loop calls poll_job_statuses() on each iteration</done>
</task>

<task type="auto">
  <name>Task 3: Enhance Job Table Status Display</name>
  <files>src/ui/jobs.rs</files>
  <action>
Update job table rendering to show quacc job status better:

**Add status color mapping for quacc jobs:**
```rust
fn quacc_status_color(status: &str) -> Color {
    match status {
        "pending" => Color::Yellow,
        "running" => Color::Green,
        "completed" => Color::Blue,
        "failed" => Color::Red,
        "cancelled" => Color::DarkGray,
        _ => Color::Gray,
    }
}
```

**Add status indicator with icon:**
```rust
fn status_display(status: &str) -> String {
    match status {
        "pending" => "⏳ Pending".to_string(),
        "running" => "▶ Running".to_string(),
        "completed" => "✓ Complete".to_string(),
        "failed" => "✗ Failed".to_string(),
        "cancelled" => "○ Cancelled".to_string(),
        _ => status.to_string(),
    }
}
```

**In job details view, show results for completed jobs:**
- If job.results_summary exists and job is completed:
  - Display energy_ev: "Energy: -123.456 eV"
  - Display max_force_ev_ang: "Max Force: 0.012 eV/Å"
  - Display formula
  - Display work_dir

**For failed jobs, show error prominently:**
- If job.error_message exists:
  - Display in red: "Error: {message}"
  - Could also show in popup on selection

**Consider adding a "last updated" timestamp:**
- Show how long ago status was polled
- Helps user know if status is fresh
  </action>
  <verify>
```bash
cd /Users/briansquires/CRYSTAL23/crystalmath
cargo build
cargo test
```
  </verify>
  <done>Job table shows colored status with icons, completed jobs show results, failed jobs show errors</done>
</task>

</tasks>

<verification>
```bash
cd /Users/briansquires/CRYSTAL23/crystalmath

# Code compiles
cargo check

# Tests pass
cargo test

# Manual verification:
# 1. Start server with a mock job in pending state
# 2. Launch TUI
# 3. Observe job table shows pending status
# 4. Wait 30 seconds
# 5. If status changed, observe table update
```
</verification>

<success_criteria>
- [ ] poll_job_statuses() sends requests only for active (non-terminal) jobs
- [ ] Polling respects 30-second interval between polls
- [ ] Status responses update quacc_jobs in App state
- [ ] Job table shows status with appropriate colors
- [ ] Completed jobs display results summary
- [ ] Failed jobs display error message
- [ ] Status changes are logged for debugging
- [ ] Polling doesn't block UI (async via bridge)
</success_criteria>

<output>
After completion, create `.planning/phases/04-job-submission/04-03-SUMMARY.md`
</output>
