#!/usr/bin/env bash
# ==============================================================================
#  CRYSTAL23 Unified Run Script - Modular Architecture
#  Version: 2.1 (Refactored Thin Orchestrator)
#  Requires: Bash 4.0+
# ==============================================================================

# SSH Color Fix
[[ "$TERM" == "xterm" || -z "$TERM" ]] && export TERM=xterm-256color

set -euo pipefail

# Bash version check (need 4.0+ for associative arrays)
if ((BASH_VERSINFO[0] < 4)); then
    echo "Error: Requires Bash 4.0+ (found ${BASH_VERSION})" >&2
    echo "Install: brew install bash" >&2
    exit 1
fi

# Determine script directory for module loading
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LIB_DIR="${SCRIPT_DIR}/../lib"

# Bootstrap core modules (cry_config_init runs automatically on source)
source "${LIB_DIR}/cry-config.sh" || { echo "FATAL: Failed to load cry-config.sh" >&2; exit 1; }

# Quick validation of CRYSTAL23 installation
cry_config_validate_quick || exit 1

source "${LIB_DIR}/cry-logging.sh" || { echo "FATAL: Failed to load cry-logging.sh" >&2; exit 1; }
source "${LIB_DIR}/core.sh" || { echo "FATAL: Failed to load core.sh" >&2; exit 1; }

# Load remaining modules
cry_require cry-ui || exit 1
cry_require cry-parallel || exit 1
cry_require cry-scratch || exit 1
cry_require cry-stage || exit 1
cry_require cry-exec || exit 1
cry_require cry-help || exit 1

# Main workflow orchestrator
main() {
    # Early exit for help
    [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]] && { help_show_main; exit 0; }

    # Parse explain mode flag
    local EXPLAIN_MODE=false
    if [[ "${1:-}" == "--explain" || "${1:-}" == "--dry-run" ]]; then
        EXPLAIN_MODE=true
        shift
    fi

    # Validate arguments
    local INPUT_ARG="${1:-}"
    local NPROCS="${2:-1}"

    if [[ -z "$INPUT_ARG" ]]; then
        ui_banner
        ui_error "No input file provided"
        echo "Usage: $(basename "$0") [--explain|--dry-run] <input> [ranks]"
        exit 1
    fi

    # Prepare file paths
    local FILE_PREFIX=$(basename "$INPUT_ARG" .d12)
    local INPUT_D12="${FILE_PREFIX}.d12"

    [[ ! -f "$INPUT_D12" ]] && { ui_error "Input file '${INPUT_D12}' not found"; exit 1; }

    # Initialize job state
    declare -A CRY_JOB
    CRY_JOB[input_d12]="$INPUT_D12"
    CRY_JOB[file_prefix]="$FILE_PREFIX"

    # Setup cleanup trap
    trap 'scratch_cleanup' EXIT

    # Configure parallelism
    parallel_setup "$NPROCS" CRY_JOB || { ui_error "Parallelism setup failed"; exit 1; }

    # Explain mode: educational output and exit
    if $EXPLAIN_MODE; then
        ui_banner
        _show_explain_mode CRY_JOB "$FILE_PREFIX" "$NPROCS"
        exit 0
    fi

    # Display job configuration
    ui_banner
    ui_card "Job Configuration" \
        "$(ui_status_line "Execution Mode" "${CRY_JOB[MODE]}")" \
        "$(ui_status_line "MPI Ranks" "${CRY_JOB[MPI_RANKS]:-1}")" \
        "$(ui_status_line "Threads/Rank" "${CRY_JOB[THREADS_PER_RANK]}")" \
        "$(ui_status_line "Binary" "$(basename "${CRY_JOB[EXE_PATH]}")")" \
        "$(ui_status_line "Input" "$INPUT_D12")"

    # Create scratch workspace
    scratch_create "$FILE_PREFIX" || { ui_error "Failed to create scratch directory"; exit 1; }

    # Stage input files
    local ORIGINAL_DIR=$(pwd)
    stage_inputs "$FILE_PREFIX" "$WORK_DIR" "$ORIGINAL_DIR" || { ui_error "Failed to stage input files"; exit 1; }

    # Execute in scratch directory
    cd "$WORK_DIR" || { ui_error "Failed to change to scratch directory"; exit 1; }

    # Run calculation, capturing exit code without triggering set -e
    # This ensures we always retrieve results and run error analysis even on failure
    local EXIT_CODE=0
    exec_crystal_run CRY_JOB || EXIT_CODE=$?

    # Always return and retrieve results (even on failure)
    cd "$ORIGINAL_DIR" || cry_warn "Failed to return to original directory"
    stage_retrieve_results "$FILE_PREFIX" "$WORK_DIR" "$ORIGINAL_DIR" || ui_warning "Some result files may not have been retrieved"

    # Report status
    echo ""
    if [[ "$EXIT_CODE" -eq 0 ]]; then
        ui_success "Calculation completed successfully"
    else
        ui_error "Calculation failed (exit code: $EXIT_CODE)"
    fi

    exit "$EXIT_CODE"
}

# Explain mode display helper
_show_explain_mode() {
    local -n job=$1
    local file_prefix="$2"
    local nprocs="$3"

    # Build execution command
    local exec_command
    if [[ "${job[MODE]}" == "Serial/OpenMP" ]]; then
        exec_command="${job[EXE_PATH]} < INPUT > ${file_prefix}.out"
    else
        local mpi_bin="mpirun"
        [[ -n "${I_MPI_ROOT:-}" ]] && mpi_bin="${I_MPI_ROOT}/bin/mpirun"
        exec_command="$mpi_bin -np ${job[MPI_RANKS]} ${job[EXE_PATH]} < INPUT > ${file_prefix}.out"
    fi

    # Display educational breakdown
    ui_card "Dry Run / Explanation Mode" \
        "$(ui_section_header "1. Hardware Detection")" \
        "   - Physical Cores: ${job[TOTAL_CORES]}" \
        "   - Requested Ranks: ${nprocs} (1 = Serial/OpenMP)" \
        "" \
        "$(ui_section_header "2. Parallel Strategy")" \
        "   - Mode: ${job[MODE]}" \
        "   - Threads per Rank: ${job[THREADS_PER_RANK]}" \
        "   - Why? This balances memory usage (MPI) with raw speed (OpenMP)" \
        "" \
        "$(ui_section_header "3. Intel Optimizations")" \
        "   - Pinning: ${I_MPI_PIN_DOMAIN:-Disabled (Serial)}" \
        "   - Affinity: ${KMP_AFFINITY:-Default}" \
        "   - Stack Size: ${OMP_STACKSIZE:-256M} (Prevents stack overflow)" \
        "" \
        "$(ui_section_header "4. File Staging")" \
        "   - Scratch Directory: ${SCRATCH_BASE}/cry_${file_prefix}_<PID>" \
        "   - Files to copy: ${INPUT_D12} + auxiliary files (.gui, .f9, .hessopt, .born)" \
        "" \
        "$(ui_section_header "5. Execution Command")" \
        "   - $exec_command"
}

# Entry point
main "$@"
