"""INCAR file builder with presets for common VASP calculations."""

from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Dict, Optional


class IncarPreset(Enum):
    """Standard INCAR presets for common calculations."""

    RELAX = "relax"  # Geometry optimization
    STATIC = "static"  # Single-point energy
    BANDS = "bands"  # Band structure (non-SCF)
    DOS = "dos"  # Density of states
    CONVERGENCE = "convergence"  # Convergence testing


@dataclass
class IncarBuilder:
    """Build INCAR files with sensible defaults.

    Attributes:
        encut: Plane-wave cutoff energy (eV). If None, should be set by generator.
        ediff: SCF energy convergence criterion (eV).
        nelm: Maximum SCF iterations.
        ismear: Smearing method (0=Gaussian, 1=Methfessel-Paxton, -5=tetrahedron).
        sigma: Smearing width (eV).
        ibrion: Ionic relaxation algorithm (-1=static, 2=CG, 1=quasi-Newton).
        isif: Stress tensor calculation (2=ions only, 3=ions+cell).
        nsw: Maximum ionic steps (0=static calculation).
        ediffg: Ionic convergence criterion (negative=force in eV/Ã…).
        lwave: Write WAVECAR file.
        lcharg: Write CHGCAR file.
        ncore: Cores per orbital for parallelization.
        extra: Additional INCAR parameters.
    """

    # Electronic convergence
    encut: Optional[float] = None
    ediff: float = 1e-6
    nelm: int = 100

    # Smearing
    ismear: int = 0
    sigma: float = 0.05

    # Ionic relaxation
    ibrion: int = -1
    isif: int = 2
    nsw: int = 0
    ediffg: float = -0.01

    # Output
    lwave: bool = False
    lcharg: bool = False

    # Parallelization
    ncore: int = 4

    # Additional parameters
    extra: Dict[str, Any] = field(default_factory=dict)

    @classmethod
    def from_preset(cls, preset: IncarPreset, **overrides) -> "IncarBuilder":
        """Create builder from preset configuration.

        Args:
            preset: One of the standard calculation presets.
            **overrides: Parameters to override from the preset defaults.

        Returns:
            Configured IncarBuilder instance.
        """
        preset_configs = {
            IncarPreset.RELAX: {
                "ibrion": 2,
                "isif": 2,
                "nsw": 100,
                "ediffg": -0.01,
            },
            IncarPreset.STATIC: {
                "ibrion": -1,
                "nsw": 0,
            },
            IncarPreset.BANDS: {
                "ibrion": -1,
                "nsw": 0,
                "extra": {"ICHARG": 11, "LORBIT": 11},
            },
            IncarPreset.DOS: {
                "ibrion": -1,
                "nsw": 0,
                "ismear": -5,
                "extra": {"NEDOS": 2001, "LORBIT": 11},
            },
            IncarPreset.CONVERGENCE: {
                "ibrion": -1,
                "nsw": 0,
                "lwave": True,
                "lcharg": True,
            },
        }

        config = preset_configs.get(preset, {})

        # Handle nested extra dict
        base_extra = config.pop("extra", {})
        override_extra = overrides.pop("extra", {})
        merged_extra = {**base_extra, **override_extra}

        # Merge all parameters
        params = {**config, **overrides}
        if merged_extra:
            params["extra"] = merged_extra

        return cls(**params)

    def to_string(self) -> str:
        """Generate INCAR file content.

        Returns:
            Complete INCAR file as a string.
        """
        lines = ["# VASP INCAR - Generated by CrystalMath", ""]

        # Electronic convergence
        lines.append("# Electronic convergence")
        if self.encut is not None:
            lines.append(f"ENCUT = {self.encut:.0f}")
        lines.append(f"EDIFF = {self.ediff:.0e}")
        lines.append(f"NELM = {self.nelm}")
        lines.append("")

        # Smearing
        lines.append("# Smearing")
        lines.append(f"ISMEAR = {self.ismear}")
        lines.append(f"SIGMA = {self.sigma}")
        lines.append("")

        # Ionic relaxation (only if NSW > 0)
        if self.nsw > 0:
            lines.append("# Ionic relaxation")
            lines.append(f"IBRION = {self.ibrion}")
            lines.append(f"ISIF = {self.isif}")
            lines.append(f"NSW = {self.nsw}")
            lines.append(f"EDIFFG = {self.ediffg}")
            lines.append("")

        # Output control
        lines.append("# Output control")
        lines.append(f"LWAVE = .{'TRUE' if self.lwave else 'FALSE'}.")
        lines.append(f"LCHARG = .{'TRUE' if self.lcharg else 'FALSE'}.")
        lines.append("")

        # Parallelization
        lines.append("# Parallelization")
        lines.append(f"NCORE = {self.ncore}")

        # Extra parameters
        if self.extra:
            lines.append("")
            lines.append("# Additional parameters")
            for key, value in sorted(self.extra.items()):
                lines.append(f"{key.upper()} = {self._format_value(value)}")

        return "\n".join(lines)

    @staticmethod
    def _format_value(value: Any) -> str:
        """Format a value for INCAR output."""
        if isinstance(value, bool):
            return f".{'TRUE' if value else 'FALSE'}."
        return str(value)
